issue_no,repo,issue_url,title,description,patched_file_types,text_for_topic_modeling,prediction,confidence
10927,traefik,https://github.com/traefik/traefik/issues/10927,Add possibility to select or deactivate compression algorithms in compress middleware,"Welcome! - [X] Yes, I've searched similar issues on [GitHub](https://github.com/traefik/traefik/issues) and didn't find any. - [X] Yes, I've searched similar issues on the [Traefik community forum](https://community.traefik.io) and didn't find any.  What did you expect to see? First of all, thanks for implementing brotli and zstd. Sadly, some firewalls don't support zstd compression yet, so websites using Traefik 3.1 with the compress middleware can cause problems in some corporate networks. So an option to allow or forbid some comporession algorithms would be great, for example:  # Enable compression http: middlewares: test-compress: compress: compressionAlgorithms: - gzip - brotli",source-file | test-file | source-file | config-file | other-file | documentation-file | documentation-file | source-file | test-file | source-file | config-file | other-file | documentation-file | documentation-file,"Add possibility to select or deactivate compression algorithms in compress middleware Welcome! - [X] Yes, I've searched similar issues on [GitHub](https://github.com/traefik/traefik/issues) and didn't find any. - [X] Yes, I've searched similar issues on the [Traefik community forum](https://community.traefik.io) and didn't find any.  What did you expect to see? First of all, thanks for implementing brotli and zstd. Sadly, some firewalls don't support zstd compression yet, so websites using Traefik 3.1 with the compress middleware can cause problems in some corporate networks. So an option to allow or forbid some comporession algorithms would be great, for example:  # Enable compression http: middlewares: test-compress: compress: compressionAlgorithms: - gzip - brotli source-file test-file source-file config-file other-file documentation-file documentation-file source-file test-file source-file config-file other-file documentation-file documentation-file",no-bug,0.9
8987,traefik,https://github.com/traefik/traefik/issues/8987,Need a way to define or alter the traefik `service name` based on consul tags,"Welcome! - [X] Yes, I've searched similar issues on [GitHub](https://github.com/traefik/traefik/issues) and didn't find any. - [X] Yes, I've searched similar issues on the [Traefik community forum](https://community.traefik.io) and didn't find any.  What did you expect to see? This is a new description of an older problem originally discussed here: https://github.com/traefik/traefik/issues/3882 That issue was originally opened in such a way that it appeared related to Traefik v1 -- however the issue affects Traefik v2 as well and @ddtmachado requested a new issue be created to describe the problem. ## Problem When using the nomad <-> consul <-> traefik integration, it is not possible to use the canary deployment workflow that is supported by nomad. An introduction to the nomad canary roll-out strategy can be found [here](https://learn.hashicorp.com/tutorials/nomad/job-blue-green-and-canary-deployments). The crux of the problem is that nomad will register the non-canary version of the service and the canary version of the service with the same consul service-name such that traefik routing policy cannot distinguish between the canary and non-canary instances of the service. Both service types are presented in traefik as one 'service' representing a pool of instances of both instance types. This means you can't use traefik routing policy to direct traffic to only one or the other instance type independently. ## Background Nomad supports a service deployment lifecycle that includes a canary deployment process. When a new version of a service that uses the canary deployment feature is deployed, nomad will spin up `n` instances of the canary service 'alongside' the existing service instances and allow the canary instances to be health-checked and verified as desired before they are 'promoted'. After promotion, the normal deployment process is followed and the running older instances are replaced with the new version. Nomad supports defining consul parameters specific for the canary instances via the [canary_tags](https://www.nomadproject.io/docs/job-specification/service#canary_tags) and [canary_meta](https://www.nomadproject.io/docs/job-specification/service#canary_meta) nomad parameters. These parameters parallel the [tags](https://www.nomadproject.io/docs/job-specification/service#tags) and [meta](https://www.nomadproject.io/docs/job-specification/service#meta) parameters that are used to populate consul for regular instances of the service. When nomad spins up canary instances it populates consul based on canary_tags/canary_meta and when nomad spins up regular instances it populates consul based on tags/meta. For both canary and non-canary instances, nomad registers the service with the same consul service-name. Nomad only allows canary/non-canary instances to differ in their presentation to consul via the canary_tags and canary_meta parameters. Traefik on the hand, considers all consul registrations with the same name to be the 'same service'. Its not currently possible to define a traefik routing policy that will route traffic to canary only or non-canary only nomad instances. As far as traefik is concerned the canary and non-canary instances are the same pool of instances and these instances can't be independently addressed.. If we could customize the presentation of the service in traefik via the nomad `canary_tags` or `canary_meta` properties in such a way as to persuade traefik to consider these instance types as two distinct services, then we would be able to take advantage of the full flexibility of traefik routing behaviors to decide how we would like to route to these now distinct-from-the-perspective-of-traefik services. ## Possible Solution I suggest allowing to define a consul parameter that allows deriving an alternate name by combining with a suffix with the base consul service name. For example -- suppose support is added for a consul tag named `traefik.consulnamesuffix` and suppose a nomad service declaration like this:  service { name = ""health-check-tool"" port = ""http"" tags = [ ""traefik.enable=true"", ""traefik.http.middlewares.strip_canary_header.headers.customrequestheaders.Canary="", ""traefik.http.routers.deploy_automation_tester.rule=Host(`${var.domain}`)"", ""traefik.http.routers.deploy_automation_tester.tls=true"", ""traefik.http.routers.deploy_automation_tester.entrypoints=https"", ""traefik.http.routers.deploy_automation_tester.middlewares=strip_canary_header@consulcatalog"" ] canary_tags = [ ""traefik.consulnamesuffix=`canary`"", ""traefik.enable=true"", ""traefik.http.routers.deploy_automation_tester_canary.rule=Host(`${var.domain}`) && Headers(`canary`, `true`)"", ""traefik.http.routers.deploy_automation_tester_canary.tls=true"", ""traefik.http.routers.deploy_automation_tester_canary.entrypoints=https"", ] connect { sidecar_service {} } check { name = ""alive"" type = ""http"" path = ""/ping"" interval = ""10s"" timeout = ""2s"" } }  While an active nomad deployment is in progress we would see two services in `traefik` -- a service named `health_check_tool` which would represent the 'old' version of the service and a service named `health_check_tool_canary` which would represent the 'new' desired version of the service that is being evaluated. In this example, there would also be two traefik routers -- one named `deploy_automation_tester` would route traffic for `${var.domain}` to `health_check_tool` and one named `deploy_automation_tester_canary` which would route traffic for `${var.domain}` that contains the `canary: true` header to the `health_check_tool_canary` service. A mechanism like this would integrate well with the nomad deployment lifecycle and would allow using the normal traefik routing policy mechanisms to send traffic to the canary/non-canary instances of the service in whatever manner is desired during deployment of a new service version.",source-file | source-file | test-file | source-file | source-file | source-file | test-file | source-file | source-file,"Need a way to define or alter the traefik `service name` based on consul tags Welcome! - [X] Yes, I've searched similar issues on [GitHub](https://github.com/traefik/traefik/issues) and didn't find any. - [X] Yes, I've searched similar issues on the [Traefik community forum](https://community.traefik.io) and didn't find any.  What did you expect to see? This is a new description of an older problem originally discussed here: https://github.com/traefik/traefik/issues/3882 That issue was originally opened in such a way that it appeared related to Traefik v1 -- however the issue affects Traefik v2 as well and @ddtmachado requested a new issue be created to describe the problem. ## Problem When using the nomad <-> consul <-> traefik integration, it is not possible to use the canary deployment workflow that is supported by nomad. An introduction to the nomad canary roll-out strategy can be found [here](https://learn.hashicorp.com/tutorials/nomad/job-blue-green-and-canary-deployments). The crux of the problem is that nomad will register the non-canary version of the service and the canary version of the service with the same consul service-name such that traefik routing policy cannot distinguish between the canary and non-canary instances of the service. Both service types are presented in traefik as one 'service' representing a pool of instances of both instance types. This means you can't use traefik routing policy to direct traffic to only one or the other instance type independently. ## Background Nomad supports a service deployment lifecycle that includes a canary deployment process. When a new version of a service that uses the canary deployment feature is deployed, nomad will spin up `n` instances of the canary service 'alongside' the existing service instances and allow the canary instances to be health-checked and verified as desired before they are 'promoted'. After promotion, the normal deployment process is followed and the running older instances are replaced with the new version. Nomad supports defining consul parameters specific for the canary instances via the [canary_tags](https://www.nomadproject.io/docs/job-specification/service#canary_tags) and [canary_meta](https://www.nomadproject.io/docs/job-specification/service#canary_meta) nomad parameters. These parameters parallel the [tags](https://www.nomadproject.io/docs/job-specification/service#tags) and [meta](https://www.nomadproject.io/docs/job-specification/service#meta) parameters that are used to populate consul for regular instances of the service. When nomad spins up canary instances it populates consul based on canary_tags/canary_meta and when nomad spins up regular instances it populates consul based on tags/meta. For both canary and non-canary instances, nomad registers the service with the same consul service-name. Nomad only allows canary/non-canary instances to differ in their presentation to consul via the canary_tags and canary_meta parameters. Traefik on the hand, considers all consul registrations with the same name to be the 'same service'. Its not currently possible to define a traefik routing policy that will route traffic to canary only or non-canary only nomad instances. As far as traefik is concerned the canary and non-canary instances are the same pool of instances and these instances can't be independently addressed.. If we could customize the presentation of the service in traefik via the nomad `canary_tags` or `canary_meta` properties in such a way as to persuade traefik to consider these instance types as two distinct services, then we would be able to take advantage of the full flexibility of traefik routing behaviors to decide how we would like to route to these now distinct-from-the-perspective-of-traefik services. ## Possible Solution I suggest allowing to define a consul parameter that allows deriving an alternate name by combining with a suffix with the base consul service name. For example -- suppose support is added for a consul tag named `traefik.consulnamesuffix` and suppose a nomad service declaration like this:  service { name = ""health-check-tool"" port = ""http"" tags = [ ""traefik.enable=true"", ""traefik.http.middlewares.strip_canary_header.headers.customrequestheaders.Canary="", ""traefik.http.routers.deploy_automation_tester.rule=Host(`${var.domain}`)"", ""traefik.http.routers.deploy_automation_tester.tls=true"", ""traefik.http.routers.deploy_automation_tester.entrypoints=https"", ""traefik.http.routers.deploy_automation_tester.middlewares=strip_canary_header@consulcatalog"" ] canary_tags = [ ""traefik.consulnamesuffix=`canary`"", ""traefik.enable=true"", ""traefik.http.routers.deploy_automation_tester_canary.rule=Host(`${var.domain}`) && Headers(`canary`, `true`)"", ""traefik.http.routers.deploy_automation_tester_canary.tls=true"", ""traefik.http.routers.deploy_automation_tester_canary.entrypoints=https"", ] connect { sidecar_service {} } check { name = ""alive"" type = ""http"" path = ""/ping"" interval = ""10s"" timeout = ""2s"" } }  While an active nomad deployment is in progress we would see two services in `traefik` -- a service named `health_check_tool` which would represent the 'old' version of the service and a service named `health_check_tool_canary` which would represent the 'new' desired version of the service that is being evaluated. In this example, there would also be two traefik routers -- one named `deploy_automation_tester` would route traffic for `${var.domain}` to `health_check_tool` and one named `deploy_automation_tester_canary` which would route traffic for `${var.domain}` that contains the `canary: true` header to the `health_check_tool_canary` service. A mechanism like this would integrate well with the nomad deployment lifecycle and would allow using the normal traefik routing policy mechanisms to send traffic to the canary/non-canary instances of the service in whatever manner is desired during deployment of a new service version. source-file source-file test-file source-file source-file source-file test-file source-file source-file",no-bug,0.9
10937,traefik,https://github.com/traefik/traefik/issues/10937,Internal Node IPs for NodePort services feature breaks namespace scoped Traefik deployments,"Welcome! - [X] Yes, I've searched similar issues on [GitHub](https://github.com/traefik/traefik/issues) and didn't find any. - [X] Yes, I've searched similar issues on the [Traefik community forum](https://community.traefik.io) and didn't find any.  What did you do? I'm running my Traefik deployments on Kubernetres in a fully name-spaced way. All Traefik RBAC permissions are configured using `Roles` and `RoleBindings`. The K8s cluster is owned by an infrastructure team and host multiple namespaces for multiple teams/clients. Until now I was able to run and configure Traefik permissions without any support from the infra team. With the [Internal Node IPs for NodePort services](https://github.com/traefik/traefik/pull/10278) feature introduced in Treafik 3.1 I no longer can do it. Traefik 3.1 requires cluster level permissions to list/watch nodes. This makes both me (as I need to ask/deploy an external team to manage/deploy my Traefik configuration) and the infrastructure team (that operate at a big scale and don't want to be bothered with an application level configurations) unhappy. As stated in the original PR comment by @rtribotte nodes are not namespaced so I fully understand why it was implemented this way. But the possibility to run Traefik in a fully namespaced way is/was a cool and useful feature that, I think, should be kept. @rtribotte are you open to refactoring the code to fetch node resources in the service namespace or other solution that will allow for fully namespaced Traefik setups? Also the documentation for [3.0 -> 3.1 migration](https://doc.traefik.io/traefik/migration/v3/) is missing any information about the new permissions requirements  What did you see instead? Traefik 3.1 can't run in Kubernetes without cluster level permissions for listing nodes  What version of Traefik are you using?  traefik version Version: 3.1.0 Codename: comte Go version: go1.22.5 Built: 2024-07-15T14:44:04Z OS/Arch: linux/amd64   What is your environment & configuration? Traefik RBAC configuration: yaml  apiVersion: v1 kind: ServiceAccount metadata: name: traefik namespace: {{ .Release.Namespace }}  apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: name: traefik-service-discovery namespace: {{ .Release.Namespace }} rules: - apiGroups: [""""] resources: [""endpoints"", ""pods"", ""secrets"", ""services"",""nodes""] verbs: [""get"", ""watch"", ""list""] - apiGroups: [""extensions"", ""networking.k8s.io""] resources: [""ingresses"", ""ingressclasses""] verbs: [""get"", ""list"", ""watch""] - apiGroups: [""traefik.io"", ""traefik.containo.us""] resources: [""ingressroutes"", ""ingressroutetcps"", ""ingressrouteudps"", ""middlewares"", ""middlewaretcps"", ""tlsoptions"", ""tlsstores"", ""traefikservices"", ""serverstransports"", ""serverstransporttcps""] verbs: [""get"", ""list"", ""watch""] - apiGroups: [""discovery.k8s.io""] resources: [""endpointslices""] verbs: [""watch"", ""list""]  kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: traefik-role-binding namespace: {{ .Release.Namespace }} subjects: - kind: ServiceAccount name: traefik namespace: {{ .Release.Namespace }} roleRef: kind: Role name: traefik-service-discovery apiGroup: rbac.authorization.k8s.io   If applicable, please paste the log output in DEBUG level _No response_",source-file | source-file | source-file | source-file | source-file | test-file | source-file,"Internal Node IPs for NodePort services feature breaks namespace scoped Traefik deployments Welcome! - [X] Yes, I've searched similar issues on [GitHub](https://github.com/traefik/traefik/issues) and didn't find any. - [X] Yes, I've searched similar issues on the [Traefik community forum](https://community.traefik.io) and didn't find any.  What did you do? I'm running my Traefik deployments on Kubernetres in a fully name-spaced way. All Traefik RBAC permissions are configured using `Roles` and `RoleBindings`. The K8s cluster is owned by an infrastructure team and host multiple namespaces for multiple teams/clients. Until now I was able to run and configure Traefik permissions without any support from the infra team. With the [Internal Node IPs for NodePort services](https://github.com/traefik/traefik/pull/10278) feature introduced in Treafik 3.1 I no longer can do it. Traefik 3.1 requires cluster level permissions to list/watch nodes. This makes both me (as I need to ask/deploy an external team to manage/deploy my Traefik configuration) and the infrastructure team (that operate at a big scale and don't want to be bothered with an application level configurations) unhappy. As stated in the original PR comment by @rtribotte nodes are not namespaced so I fully understand why it was implemented this way. But the possibility to run Traefik in a fully namespaced way is/was a cool and useful feature that, I think, should be kept. @rtribotte are you open to refactoring the code to fetch node resources in the service namespace or other solution that will allow for fully namespaced Traefik setups? Also the documentation for [3.0 -> 3.1 migration](https://doc.traefik.io/traefik/migration/v3/) is missing any information about the new permissions requirements  What did you see instead? Traefik 3.1 can't run in Kubernetes without cluster level permissions for listing nodes  What version of Traefik are you using?  traefik version Version: 3.1.0 Codename: comte Go version: go1.22.5 Built: 2024-07-15T14:44:04Z OS/Arch: linux/amd64   What is your environment & configuration? Traefik RBAC configuration: yaml  apiVersion: v1 kind: ServiceAccount metadata: name: traefik namespace: {{ .Release.Namespace }}  apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: name: traefik-service-discovery namespace: {{ .Release.Namespace }} rules: - apiGroups: [""""] resources: [""endpoints"", ""pods"", ""secrets"", ""services"",""nodes""] verbs: [""get"", ""watch"", ""list""] - apiGroups: [""extensions"", ""networking.k8s.io""] resources: [""ingresses"", ""ingressclasses""] verbs: [""get"", ""list"", ""watch""] - apiGroups: [""traefik.io"", ""traefik.containo.us""] resources: [""ingressroutes"", ""ingressroutetcps"", ""ingressrouteudps"", ""middlewares"", ""middlewaretcps"", ""tlsoptions"", ""tlsstores"", ""traefikservices"", ""serverstransports"", ""serverstransporttcps""] verbs: [""get"", ""list"", ""watch""] - apiGroups: [""discovery.k8s.io""] resources: [""endpointslices""] verbs: [""watch"", ""list""]  kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: traefik-role-binding namespace: {{ .Release.Namespace }} subjects: - kind: ServiceAccount name: traefik namespace: {{ .Release.Namespace }} roleRef: kind: Role name: traefik-service-discovery apiGroup: rbac.authorization.k8s.io   If applicable, please paste the log output in DEBUG level _No response_ source-file source-file source-file source-file source-file test-file source-file",no-bug,0.9
10996,traefik,https://github.com/traefik/traefik/issues/10996,Plugin: Parsing string array in nested config structs doesn't work,"Welcome! - [X] Yes, I've searched similar issues on [GitHub](https://github.com/traefik/traefik/issues) and didn't find any. - [X] Yes, I've searched similar issues on the [Traefik community forum](https://community.traefik.io) and didn't find any.  What did you do? I'am working on a traefik plugin where i want to configure the plugin using a yaml-array. This works fine on top-level, but not on a nested one. I found the following depending PRs: - https://github.com/traefik/traefik/pull/8886 - https://github.com/traefik/paerser/pull/15 They all talk about traefik 2.x but i'am using 3.1. Is there something missing in v3? Here is my code: **Config:** yml middlewares: oidc-auth: plugin: traefik-oidc-auth: Authorization: AssertClaims: - Name: ""preferred_username"" Values: [""value1"", ""value2"", ""value3""]  **Structs:** go type Config struct { Authorization *AuthorizationConfig `json:""authorization""` } type AuthorizationConfig struct { AssertClaims []ClaimAssertion `json:""assert_claims""` } type ClaimAssertion struct { Name string `json:""name""` Value string `json:""value""` Values []string `json:""values""` }   What did you see instead? When i loop over the Values-array, i get: `[24value1value2value3]` Instead, i'am expecting to get a real array. The only workaround is to use: yml Values: ""value1,value2,value3""   What version of Traefik are you using? Version: 3.1.2 Codename: comte Go version: go1.22.5 Built: 2024-08-06T13:37:51Z OS/Arch: linux/amd64  What is your environment & configuration? yaml global: checkNewVersion: true sendAnonymousUsage: true entryPoints: web: address: :80 # Enable API and dashboard api: insecure: true dashboard: true debug: true experimental: localPlugins: traefik-oidc-auth: moduleName: github.com/sevensolutions/traefik-oidc-auth providers: file: filename: /etc/traefik/configs/http.yml watch: true   If applicable, please paste the log output in DEBUG level _No response_",source-file | test-file | source-file,"Plugin: Parsing string array in nested config structs doesn't work Welcome! - [X] Yes, I've searched similar issues on [GitHub](https://github.com/traefik/traefik/issues) and didn't find any. - [X] Yes, I've searched similar issues on the [Traefik community forum](https://community.traefik.io) and didn't find any.  What did you do? I'am working on a traefik plugin where i want to configure the plugin using a yaml-array. This works fine on top-level, but not on a nested one. I found the following depending PRs: - https://github.com/traefik/traefik/pull/8886 - https://github.com/traefik/paerser/pull/15 They all talk about traefik 2.x but i'am using 3.1. Is there something missing in v3? Here is my code: **Config:** yml middlewares: oidc-auth: plugin: traefik-oidc-auth: Authorization: AssertClaims: - Name: ""preferred_username"" Values: [""value1"", ""value2"", ""value3""]  **Structs:** go type Config struct { Authorization *AuthorizationConfig `json:""authorization""` } type AuthorizationConfig struct { AssertClaims []ClaimAssertion `json:""assert_claims""` } type ClaimAssertion struct { Name string `json:""name""` Value string `json:""value""` Values []string `json:""values""` }   What did you see instead? When i loop over the Values-array, i get: `[24value1value2value3]` Instead, i'am expecting to get a real array. The only workaround is to use: yml Values: ""value1,value2,value3""   What version of Traefik are you using? Version: 3.1.2 Codename: comte Go version: go1.22.5 Built: 2024-08-06T13:37:51Z OS/Arch: linux/amd64  What is your environment & configuration? yaml global: checkNewVersion: true sendAnonymousUsage: true entryPoints: web: address: :80 # Enable API and dashboard api: insecure: true dashboard: true debug: true experimental: localPlugins: traefik-oidc-auth: moduleName: github.com/sevensolutions/traefik-oidc-auth providers: file: filename: /etc/traefik/configs/http.yml watch: true   If applicable, please paste the log output in DEBUG level _No response_ source-file test-file source-file",no-bug,0.9
11313,traefik,https://github.com/traefik/traefik/issues/11313,Middleware of ForwardAuth returns incorrect location header,"Welcome! - [x] Yes, I've searched similar issues on [GitHub](https://github.com/traefik/traefik/issues) and didn't find any. - [x] Yes, I've searched similar issues on the [Traefik community forum](https://community.traefik.io) and didn't find any.  What did you do? I made an auth server that returns a relative url as the Location header in the response. I'm expecting the relative url will be passed to the downstream and then be resolved by the browser or other clients.  What did you see instead? ForwardAuth middleware resolves the location header and return the resolved url as the location header in the response. While the correct behavior should just return the original location header. https://github.com/traefik/traefik/blob/33c1d700c02ad09ab793673a14674b39d78fe352/pkg/middlewares/auth/forward.go#L193 For example, - Auth server endpoint address: http://forward-auth.server.local:8080/auth - Auth server response Location header: /index.html - Downstream received response Location header: http://forward-auth.server.local:8080/index.html - Expected Location header: /index.html Note, that the location should be resolved at the customer side, like the browser, which should be relative to the original forwarded domain, not the auth server.  What version of Traefik are you using? v3.1.6 I checked the latest code. It seems it's still the same behavior.  What is your environment & configuration? Not related. But can provide if being asked.  If applicable, please paste the log output in DEBUG level _No response_",source-file | test-file | source-file | test-file | source-file | test-file | source-file | test-file | source-file | test-file | source-file | test-file,"Middleware of ForwardAuth returns incorrect location header Welcome! - [x] Yes, I've searched similar issues on [GitHub](https://github.com/traefik/traefik/issues) and didn't find any. - [x] Yes, I've searched similar issues on the [Traefik community forum](https://community.traefik.io) and didn't find any.  What did you do? I made an auth server that returns a relative url as the Location header in the response. I'm expecting the relative url will be passed to the downstream and then be resolved by the browser or other clients.  What did you see instead? ForwardAuth middleware resolves the location header and return the resolved url as the location header in the response. While the correct behavior should just return the original location header. https://github.com/traefik/traefik/blob/33c1d700c02ad09ab793673a14674b39d78fe352/pkg/middlewares/auth/forward.go#L193 For example, - Auth server endpoint address: http://forward-auth.server.local:8080/auth - Auth server response Location header: /index.html - Downstream received response Location header: http://forward-auth.server.local:8080/index.html - Expected Location header: /index.html Note, that the location should be resolved at the customer side, like the browser, which should be relative to the original forwarded domain, not the auth server.  What version of Traefik are you using? v3.1.6 I checked the latest code. It seems it's still the same behavior.  What is your environment & configuration? Not related. But can provide if being asked.  If applicable, please paste the log output in DEBUG level _No response_ source-file test-file source-file test-file source-file test-file source-file test-file source-file test-file source-file test-file",bug,0.9
