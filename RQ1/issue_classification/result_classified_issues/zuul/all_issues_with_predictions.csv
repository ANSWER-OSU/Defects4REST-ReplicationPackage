issue_no,repo,issue_url,title,description,patched_file_types,text_for_topic_modeling,prediction,confidence
315,zuul,https://github.com/Netflix/zuul/issues/315,Namespace confusion is happening with OpenStack's Zuul project,"Hi! I work on the Zuul project started by OpenStack developers back in 2012: https://github.com/openstack-infra/zuul/tree/1.1.0 We've known for a while that there was a name collision when Netflix released its Zuul project. However, we may need to do something to disambiguate, as we have at least one example of confusion around the name: https://thenewstack.io/ibm-openstack-engineer-urges-cncf-consider-augmenting-jenkins-zuul/ We should work together to find a solution to this. Thanks!",documentation-file | documentation-file,"Namespace confusion is happening with OpenStack's Zuul project Hi! I work on the Zuul project started by OpenStack developers back in 2012: https://github.com/openstack-infra/zuul/tree/1.1.0 We've known for a while that there was a name collision when Netflix released its Zuul project. However, we may need to do something to disambiguate, as we have at least one example of confusion around the name: https://thenewstack.io/ibm-openstack-engineer-urges-cncf-consider-augmenting-jenkins-zuul/ We should work together to find a solution to this. Thanks! documentation-file documentation-file",no-bug,0.9
428,zuul,https://github.com/Netflix/zuul/issues/428,ProxyEndpoint https,Is the proxy endpoint able to handle https endpoints or is a custom endpoint needed? referencing Zuul version 2.1,config-file | source-file | source-file | source-file | config-file | source-file | source-file | source-file | config-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | source-file | config-file | config-file | source-file | source-file | source-file | source-file,ProxyEndpoint https Is the proxy endpoint able to handle https endpoints or is a custom endpoint needed? referencing Zuul version 2.1 config-file source-file source-file source-file config-file source-file source-file source-file config-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file source-file config-file config-file source-file source-file source-file source-file,no-bug,0.3
127,zuul,https://github.com/Netflix/zuul/issues/127,Zuul/Hystrix: HTTP connection leak in case of timeout,"See https://github.com/spring-cloud/spring-cloud-netflix/issues/327 for a complete description of the issue and scenarios to reproduce it. The bottom line is: > It turns out that Zuul leaks HTTP connections if a service takes longer than the Hystrix execution timeout but less than the ReadTimeout. To summarise: > > execTime < hystrixTimeout < readTimeout --> OK (no leak) > hystrixTimeout < execTime < readTimeout --> LEAK > hystrixTimeout < readTimeout < execTime --> OK (no leak) > readTimeout < execTime < hystrixTimeout --> OK (no leak) > readTimeout < hystrixTimeout < execTime --> LEAK The problem has been identified in the `RibbonCommand` returning an `HttpResponse` that will never be closed in case of Hystrix timeout. Hence causing connection leaks in the HTTP connection pool. Although the issue affects SpringCloud's version of the Zuul server, it seems that `com.netflix.zuul.dependency.ribbon.hystrix.RibbonCommand` would be affected as well.",source-file | source-file,"Zuul/Hystrix: HTTP connection leak in case of timeout See https://github.com/spring-cloud/spring-cloud-netflix/issues/327 for a complete description of the issue and scenarios to reproduce it. The bottom line is: > It turns out that Zuul leaks HTTP connections if a service takes longer than the Hystrix execution timeout but less than the ReadTimeout. To summarise: > > execTime < hystrixTimeout < readTimeout --> OK (no leak) > hystrixTimeout < execTime < readTimeout --> LEAK > hystrixTimeout < readTimeout < execTime --> OK (no leak) > readTimeout < execTime < hystrixTimeout --> OK (no leak) > readTimeout < hystrixTimeout < execTime --> LEAK The problem has been identified in the `RibbonCommand` returning an `HttpResponse` that will never be closed in case of Hystrix timeout. Hence causing connection leaks in the HTTP connection pool. Although the issue affects SpringCloud's version of the Zuul server, it seems that `com.netflix.zuul.dependency.ribbon.hystrix.RibbonCommand` would be affected as well. source-file source-file",no-bug,0.9
1825,zuul,https://github.com/Netflix/zuul/issues/1825,No check if connection already exists for given client,"Problem description When adding new connection to the registry (`PushConnectionRegistry`) there is no check if a connection already exists for given client identity. So, in case when: - there is a connection (`connection1`) for given client in the registry and - a request for new connection(`connection2`) and the same client is received then: the previous connection (`connection1`) is replaced by the new one (`connection2`) in the registry. But the `connection1` is not closed - so `connection1` remains open, but there is no possibility to manage it - as the reference to the connection has been lost. Also, if KEEP_ALIVE_ENABLED` is true, the ping events are still sent to the` connection1`.  Steps to reproduce 1. Open two connection for the same client identity, e.g: In two terminal's windows send a registration request for the same user :  curl -v ""http://localhost:7001/sse"" \ --header 'Accept: text/event-stream' \ -b 'userAuthCookie=exampleClient'  Observe - when the second connection is open, the first remains open as well then send push message to `exampleClient` :  curl -v http://localhost:7008/push \ --header 'X-CUSTOMER_ID: exampleClient' \ -d 'some example message'  check if the message has been received - it'll appear only in second terminal window - for the connection that was opened last. The first connection won't receive the message, but the connection remains open.  Suggested solution Checking if a connection already exists in the registry for given client. If so, error event is sent to the new connection and the new connection is closed. PR : https://github.com/Netflix/zuul/pull/1826",source-file | test-file | source-file | test-file,"No check if connection already exists for given client Problem description When adding new connection to the registry (`PushConnectionRegistry`) there is no check if a connection already exists for given client identity. So, in case when: - there is a connection (`connection1`) for given client in the registry and - a request for new connection(`connection2`) and the same client is received then: the previous connection (`connection1`) is replaced by the new one (`connection2`) in the registry. But the `connection1` is not closed - so `connection1` remains open, but there is no possibility to manage it - as the reference to the connection has been lost. Also, if KEEP_ALIVE_ENABLED` is true, the ping events are still sent to the` connection1`.  Steps to reproduce 1. Open two connection for the same client identity, e.g: In two terminal's windows send a registration request for the same user :  curl -v ""http://localhost:7001/sse"" \ --header 'Accept: text/event-stream' \ -b 'userAuthCookie=exampleClient'  Observe - when the second connection is open, the first remains open as well then send push message to `exampleClient` :  curl -v http://localhost:7008/push \ --header 'X-CUSTOMER_ID: exampleClient' \ -d 'some example message'  check if the message has been received - it'll appear only in second terminal window - for the connection that was opened last. The first connection won't receive the message, but the connection remains open.  Suggested solution Checking if a connection already exists in the registry for given client. If so, error event is sent to the new connection and the new connection is closed. PR : https://github.com/Netflix/zuul/pull/1826 source-file test-file source-file test-file",no-bug,0.8
569,zuul,https://github.com/Netflix/zuul/issues/569,.travis.yml: The 'sudo' tag is now deprecated in Travis CI,"[Travis are now recommending removing the __sudo__ tag](https://blog.travis-ci.com/2018-11-19-required-linux-infrastructure-migration). ""_If you currently specify __sudo: false__ in your __.travis.yml__, we recommend removing that configuration_""",config-file | config-file,".travis.yml: The 'sudo' tag is now deprecated in Travis CI [Travis are now recommending removing the __sudo__ tag](https://blog.travis-ci.com/2018-11-19-required-linux-infrastructure-migration). ""_If you currently specify __sudo: false__ in your __.travis.yml__, we recommend removing that configuration_"" config-file config-file",no-bug,0.95
230,zuul,https://github.com/Netflix/zuul/issues/230,HttpServletRequestWrapper.getRequest returns wrapped request,"Since #213 has been fixed I've encountered a never ending while loop in Tomcat's [`ApplicationDispatcher`](https://github.com/apache/tomcat/blob/TOMCAT_8_0_0/java/org/apache/catalina/core/ApplicationDispatcher.java#L907-L908).  if (!(current instanceof ServletRequestWrapper)) break;  The request is always a `ServletRequestWrapper` unless I unwrap it. Prior to #213 `HttpServletRequestWrapper` did not extend `ServletRequestWrapper`, therefor the loop exited. As I tried to integrate zuul 1.2.2 @markt-asf (tomcat committer) noted in https://github.com/spring-cloud/spring-cloud-netflix/pull/1106#discussion_r67402882 that `HttpServletRequestWrapper.getRequest()` returns wrapped request, which is a bug. I [work around](https://github.com/spring-cloud/spring-cloud-netflix/pull/1106) the issue by overriding `getRequest()` and returning the original request.",source-file,"HttpServletRequestWrapper.getRequest returns wrapped request Since #213 has been fixed I've encountered a never ending while loop in Tomcat's [`ApplicationDispatcher`](https://github.com/apache/tomcat/blob/TOMCAT_8_0_0/java/org/apache/catalina/core/ApplicationDispatcher.java#L907-L908).  if (!(current instanceof ServletRequestWrapper)) break;  The request is always a `ServletRequestWrapper` unless I unwrap it. Prior to #213 `HttpServletRequestWrapper` did not extend `ServletRequestWrapper`, therefor the loop exited. As I tried to integrate zuul 1.2.2 @markt-asf (tomcat committer) noted in https://github.com/spring-cloud/spring-cloud-netflix/pull/1106#discussion_r67402882 that `HttpServletRequestWrapper.getRequest()` returns wrapped request, which is a bug. I [work around](https://github.com/spring-cloud/spring-cloud-netflix/pull/1106) the issue by overriding `getRequest()` and returning the original request. source-file",no-bug,0.9
11,zuul,https://github.com/Netflix/zuul/issues/11,Enable filter execution summary in request context,Feature to insert filter execution status and latency information into the request context for use in response headers. This information is useful in identifying the filters that are participating in the lifecycle of a request that is processed by zuul.,source-file | source-file | source-file | source-file | source-file,Enable filter execution summary in request context Feature to insert filter execution status and latency information into the request context for use in response headers. This information is useful in identifying the filters that are participating in the lifecycle of a request that is processed by zuul. source-file source-file source-file source-file source-file,no-bug,0.9
213,zuul,https://github.com/Netflix/zuul/issues/213,Some containers require RequestWrapper extend ServletRequestWrapper or HttpServletRequestWrapper,WAS Liberty https://github.com/spring-cloud/spring-cloud-netflix/issues/958 See also https://github.com/spring-cloud/spring-cloud-netflix/issues/397 Looks like changing https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/http/HttpServletRequestWrapper.java#L58 to `public class HttpServletRequestWrapper extends ServletRequestWrapper implements HttpServletRequest` Would have the desired outcome.,source-file,Some containers require RequestWrapper extend ServletRequestWrapper or HttpServletRequestWrapper WAS Liberty https://github.com/spring-cloud/spring-cloud-netflix/issues/958 See also https://github.com/spring-cloud/spring-cloud-netflix/issues/397 Looks like changing https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/http/HttpServletRequestWrapper.java#L58 to `public class HttpServletRequestWrapper extends ServletRequestWrapper implements HttpServletRequest` Would have the desired outcome. source-file,no-bug,0.8
12,zuul,https://github.com/Netflix/zuul/issues/12,Filters have the wrong package name,Fix the package name to be consistent with the directory where they are located,other-file | other-file | other-file | other-file | other-file | other-file | other-file | other-file | other-file | other-file | other-file | other-file | other-file,Filters have the wrong package name Fix the package name to be consistent with the directory where they are located other-file other-file other-file other-file other-file other-file other-file other-file other-file other-file other-file other-file other-file,no-bug,0.9
13,zuul,https://github.com/Netflix/zuul/issues/13,Change the default response code,"For requests processed by Zuul, the default response code is 200. Returning a 200 has the potential to mask issues with routing filter changes. Making the default response status a 500 will allow for finding issues earlier. When a request is proxied to a backend, the status code for the proxy action is set by Zuul based on the response from the backend. However if the filter is not a static response filter and the response never enters the route/proxy filter process an empty response is sent out by zuul with a 200. Changes need to be made to prevent it from happening.",other-file | source-file | source-file,"Change the default response code For requests processed by Zuul, the default response code is 200. Returning a 200 has the potential to mask issues with routing filter changes. Making the default response status a 500 will allow for finding issues earlier. When a request is proxied to a backend, the status code for the proxy action is set by Zuul based on the response from the backend. However if the filter is not a static response filter and the response never enters the route/proxy filter process an empty response is sent out by zuul with a 200. Changes need to be made to prevent it from happening. other-file source-file source-file",bug,0.9
169,zuul,https://github.com/Netflix/zuul/issues/169,setOriginContentLength in RequestContext fails for all files larger than 2.15 GB,"setOriginContentLength in RequestContext uses Integer.parseInt to parse the content length. However, this will fail for any file larger than 2.15GB (max int is 2147483647). https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/context/RequestContext.java",source-file | source-file,"setOriginContentLength in RequestContext fails for all files larger than 2.15 GB setOriginContentLength in RequestContext uses Integer.parseInt to parse the content length. However, this will fail for any file larger than 2.15GB (max int is 2147483647). https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/context/RequestContext.java source-file source-file",bug,0.9
29,zuul,https://github.com/Netflix/zuul/issues/29,Intellij IDEA module structure not quite right?,"TL;DR: some of IDEA's cool static analysis features don't work right with zuul code. The only solution I can come up with on my own may be too invasive, since it touches on separating test/prod code. I am using Intellij IDEA 13.1.3 (latest) with the Zuul code, and my main goal is to use the IDE to browse/analyze the code (e.g. `Find Usages`, `Navigate -> Implementations`, `Navigate -> Call Hierarchy`). There are two probably-related problems I'm having ""out of the box"" (clean git clone; `./gradlew idea`; open `zuul.ipr` in IDEA [with the Groovy and Gradle plugins active]): 1. Groovy files are not recognized - e.g. `Navigate -> Implementations` on `ZuulFilter` only finds the Java implementors, not any of the Groovy ones). 2. IDEA's ability to filter test code from production code is hampered by the fact that IDEA thinks all the code is test code. These may be separate underlying issues; I'm including them both in this entry as I believe they are related enough to discuss together. To solve #1 we can ""repair"" the module structures; I say repair because IDEA itself doesn't like the fact that src/main/java appears twice each module, once for test and once for non-test:  $ grep src/main/java */*.iml zuul-core/zuul-core.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""false"" /> zuul-core/zuul-core.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""true"" /> zuul-netflix-webapp/zuul-netflix-webapp.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""false"" /> zuul-netflix-webapp/zuul-netflix-webapp.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""true"" /> zuul-netflix/zuul-netflix.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""false"" /> zuul-netflix/zuul-netflix.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""true"" /> zuul-simple-webapp/zuul-simple-webapp.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""false"" /> zuul-simple-webapp/zuul-simple-webapp.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""true"" />  Without resolving all of those (e.g. remove the ""true"" entries), any changes to the module structure will cause IDEA to complain (e.g. if you try to apply any change at all) as it doesn't expect duplicate entries. Resolving all of them will satisfy it, and then Problem #1 above seems to go away. Problem #2 is of course also related to the test/prod distinction. My selfish knee-jerk solution would be to separate test code into src/test/\* and remove this one line from [build.gradle](https://github.com/Netflix/zuul/blob/master/build.gradle):  sourceSets.test.java.srcDir 'src/main/java'  However I am aware of [Ben Christensen's viewpoint on test/production code](http://benjchristensen.com/2011/10/23/junit-tests-as-inner-classes/), and that not all zuul developers use IDEA and/or value static code analysis as much as I do. I also agree in spirit that code readability should trump tool concerns, if there is indeed an unavoidable tradeoff. If this can be resolved somehow, I consider it a big win for IDEA users, since the Navigation/Inspection features are so powerful, and help developers come up the learning curve. It's a good complement to learning via debug/breakpoints, which for `zuul-netflix-webapp` is a bit more non-trivial as it requires getting all the components up and running.",config-file,"Intellij IDEA module structure not quite right? TL;DR: some of IDEA's cool static analysis features don't work right with zuul code. The only solution I can come up with on my own may be too invasive, since it touches on separating test/prod code. I am using Intellij IDEA 13.1.3 (latest) with the Zuul code, and my main goal is to use the IDE to browse/analyze the code (e.g. `Find Usages`, `Navigate -> Implementations`, `Navigate -> Call Hierarchy`). There are two probably-related problems I'm having ""out of the box"" (clean git clone; `./gradlew idea`; open `zuul.ipr` in IDEA [with the Groovy and Gradle plugins active]): 1. Groovy files are not recognized - e.g. `Navigate -> Implementations` on `ZuulFilter` only finds the Java implementors, not any of the Groovy ones). 2. IDEA's ability to filter test code from production code is hampered by the fact that IDEA thinks all the code is test code. These may be separate underlying issues; I'm including them both in this entry as I believe they are related enough to discuss together. To solve #1 we can ""repair"" the module structures; I say repair because IDEA itself doesn't like the fact that src/main/java appears twice each module, once for test and once for non-test:  $ grep src/main/java */*.iml zuul-core/zuul-core.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""false"" /> zuul-core/zuul-core.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""true"" /> zuul-netflix-webapp/zuul-netflix-webapp.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""false"" /> zuul-netflix-webapp/zuul-netflix-webapp.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""true"" /> zuul-netflix/zuul-netflix.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""false"" /> zuul-netflix/zuul-netflix.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""true"" /> zuul-simple-webapp/zuul-simple-webapp.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""false"" /> zuul-simple-webapp/zuul-simple-webapp.iml: <sourceFolder url=""file://$MODULE_DIR$/src/main/java"" isTestSource=""true"" />  Without resolving all of those (e.g. remove the ""true"" entries), any changes to the module structure will cause IDEA to complain (e.g. if you try to apply any change at all) as it doesn't expect duplicate entries. Resolving all of them will satisfy it, and then Problem #1 above seems to go away. Problem #2 is of course also related to the test/prod distinction. My selfish knee-jerk solution would be to separate test code into src/test/\* and remove this one line from [build.gradle](https://github.com/Netflix/zuul/blob/master/build.gradle):  sourceSets.test.java.srcDir 'src/main/java'  However I am aware of [Ben Christensen's viewpoint on test/production code](http://benjchristensen.com/2011/10/23/junit-tests-as-inner-classes/), and that not all zuul developers use IDEA and/or value static code analysis as much as I do. I also agree in spirit that code readability should trump tool concerns, if there is indeed an unavoidable tradeoff. If this can be resolved somehow, I consider it a big win for IDEA users, since the Navigation/Inspection features are so powerful, and help developers come up the learning curve. It's a good complement to learning via debug/breakpoints, which for `zuul-netflix-webapp` is a bit more non-trivial as it requires getting all the components up and running. config-file",no-bug,0.95
101,zuul,https://github.com/Netflix/zuul/issues/101,Can't use ZuulException in the filters,You cant use ZuulException in the filter's run method because run not throws ZuulException and ZuulException is not RuntimeException,other-file | source-file | source-file,Can't use ZuulException in the filters You cant use ZuulException in the filter's run method because run not throws ZuulException and ZuulException is not RuntimeException other-file source-file source-file,no-bug,0.9
129,zuul,https://github.com/Netflix/zuul/issues/129,Conflicting module versions groovy-all,"Hi, I'm trying to run the zuul simple webapp example and I get this exception when executing `../gradlew jettyRun`: SLF4J: Failed to load class ""org.slf4j.impl.StaticLoggerBinder"". SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details. failed org.gradle.api.plugins.jetty.internal.JettyPluginWebAppContext@fa8de42{/,/home/gonza/workspace/zuul/zuul-simple-webapp/src/main/webapp}: java.lang.ExceptionInInitializerError failed ContextHandlerCollection@4d499f71: java.lang.ExceptionInInitializerError failed HandlerCollection@1c82db5b: java.lang.ExceptionInInitializerError Error starting handlers java.lang.ExceptionInInitializerError at org.codehaus.groovy.runtime.InvokerHelper.<clinit>(InvokerHelper.java:61) at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:72) at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:159) at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112) at scripts.preProcess.DebugFilter.<clinit>(Debug.groovy:27) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:526) at java.lang.Class.newInstance(Class.java:383) at com.netflix.zuul.DefaultFilterFactory.newInstance(DefaultFilterFactory.java:17) at com.netflix.zuul.FilterLoader.putFilter(FilterLoader.java:156) at com.netflix.zuul.FilterFileManager.processGroovyFiles(FilterFileManager.java:170) at com.netflix.zuul.FilterFileManager.manageFiles(FilterFileManager.java:176) at com.netflix.zuul.FilterFileManager.init(FilterFileManager.java:81) at com.netflix.zuul.StartServer.initGroovyFilterManager(StartServer.java:63) at com.netflix.zuul.StartServer.contextInitialized(StartServer.java:45) at org.mortbay.jetty.handler.ContextHandler.startContext(ContextHandler.java:548) at org.mortbay.jetty.servlet.Context.startContext(Context.java:136) at org.mortbay.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1272) at org.mortbay.jetty.handler.ContextHandler.doStart(ContextHandler.java:517) at org.mortbay.jetty.webapp.WebAppContext.doStart(WebAppContext.java:489) at org.gradle.api.plugins.jetty.internal.JettyPluginWebAppContext.doStart(JettyPluginWebAppContext.java:112) at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50) at org.mortbay.jetty.handler.HandlerCollection.doStart(HandlerCollection.java:152) at org.mortbay.jetty.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:156) at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50) at org.mortbay.jetty.handler.HandlerCollection.doStart(HandlerCollection.java:152) at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50) at org.mortbay.jetty.handler.HandlerWrapper.doStart(HandlerWrapper.java:130) at org.mortbay.jetty.Server.doStart(Server.java:224) at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50) at org.gradle.api.plugins.jetty.internal.Jetty6PluginServer.start(Jetty6PluginServer.java:111) at org.gradle.api.plugins.jetty.AbstractJettyRunTask.startJettyInternal(AbstractJettyRunTask.java:238) at org.gradle.api.plugins.jetty.AbstractJettyRunTask.startJetty(AbstractJettyRunTask.java:191) at org.gradle.api.plugins.jetty.AbstractJettyRunTask.start(AbstractJettyRunTask.java:162) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:63) at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:218) at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:211) at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:200) at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:579) at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:562) at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80) at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61) at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46) at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35) at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64) at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58) at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42) at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52) at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53) at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43) at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:305) at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79) at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63) at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51) at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:23) at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:88) at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:29) at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:62) at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23) at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:68) at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32) at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:62) at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:55) at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:149) at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:106) at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:86) at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:80) at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:33) at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:24) at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:36) at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:26) at org.gradle.launcher.cli.RunBuildAction.run(RunBuildAction.java:51) at org.gradle.internal.Actions$RunnableActionAdapter.execute(Actions.java:171) at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:237) at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:210) at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:35) at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:24) at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:206) at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:169) at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:33) at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:22) at org.gradle.launcher.Main.doAction(Main.java:33) at org.gradle.launcher.bootstrap.EntryPoint.run(EntryPoint.java:45) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.gradle.launcher.bootstrap.ProcessBootstrap.runNoExit(ProcessBootstrap.java:54) at org.gradle.launcher.bootstrap.ProcessBootstrap.run(ProcessBootstrap.java:35) at org.gradle.launcher.GradleMain.main(GradleMain.java:23) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.gradle.wrapper.BootstrapMainStarter.start(BootstrapMainStarter.java:30) at org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:127) at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:56) Caused by: groovy.lang.GroovyRuntimeException: Conflicting module versions. Module [groovy-all is loaded in version 2.3.6 and you are trying to load version 2.3.1 at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl$DefaultModuleListener.onModule(MetaClassRegistryImpl.java:509) at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanExtensionModuleFromProperties(ExtensionModuleScanner.java:78) at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanExtensionModuleFromMetaInf(ExtensionModuleScanner.java:72) at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanClasspathModules(ExtensionModuleScanner.java:54) at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:110) at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:71) at groovy.lang.GroovySystem.<clinit>(GroovySystem.java:33)  105 more Building remains at 90% and when I query localhost:8080 I get a Jetty error page. Am I doing something wrong? I've read that Jetty plugin is somewhat outdated so it may be using and older version of groovy-all module",config-file | source-file | source-file | source-file | source-file,"Conflicting module versions groovy-all Hi, I'm trying to run the zuul simple webapp example and I get this exception when executing `../gradlew jettyRun`: SLF4J: Failed to load class ""org.slf4j.impl.StaticLoggerBinder"". SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details. failed org.gradle.api.plugins.jetty.internal.JettyPluginWebAppContext@fa8de42{/,/home/gonza/workspace/zuul/zuul-simple-webapp/src/main/webapp}: java.lang.ExceptionInInitializerError failed ContextHandlerCollection@4d499f71: java.lang.ExceptionInInitializerError failed HandlerCollection@1c82db5b: java.lang.ExceptionInInitializerError Error starting handlers java.lang.ExceptionInInitializerError at org.codehaus.groovy.runtime.InvokerHelper.<clinit>(InvokerHelper.java:61) at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:72) at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:159) at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112) at scripts.preProcess.DebugFilter.<clinit>(Debug.groovy:27) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:526) at java.lang.Class.newInstance(Class.java:383) at com.netflix.zuul.DefaultFilterFactory.newInstance(DefaultFilterFactory.java:17) at com.netflix.zuul.FilterLoader.putFilter(FilterLoader.java:156) at com.netflix.zuul.FilterFileManager.processGroovyFiles(FilterFileManager.java:170) at com.netflix.zuul.FilterFileManager.manageFiles(FilterFileManager.java:176) at com.netflix.zuul.FilterFileManager.init(FilterFileManager.java:81) at com.netflix.zuul.StartServer.initGroovyFilterManager(StartServer.java:63) at com.netflix.zuul.StartServer.contextInitialized(StartServer.java:45) at org.mortbay.jetty.handler.ContextHandler.startContext(ContextHandler.java:548) at org.mortbay.jetty.servlet.Context.startContext(Context.java:136) at org.mortbay.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1272) at org.mortbay.jetty.handler.ContextHandler.doStart(ContextHandler.java:517) at org.mortbay.jetty.webapp.WebAppContext.doStart(WebAppContext.java:489) at org.gradle.api.plugins.jetty.internal.JettyPluginWebAppContext.doStart(JettyPluginWebAppContext.java:112) at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50) at org.mortbay.jetty.handler.HandlerCollection.doStart(HandlerCollection.java:152) at org.mortbay.jetty.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:156) at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50) at org.mortbay.jetty.handler.HandlerCollection.doStart(HandlerCollection.java:152) at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50) at org.mortbay.jetty.handler.HandlerWrapper.doStart(HandlerWrapper.java:130) at org.mortbay.jetty.Server.doStart(Server.java:224) at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50) at org.gradle.api.plugins.jetty.internal.Jetty6PluginServer.start(Jetty6PluginServer.java:111) at org.gradle.api.plugins.jetty.AbstractJettyRunTask.startJettyInternal(AbstractJettyRunTask.java:238) at org.gradle.api.plugins.jetty.AbstractJettyRunTask.startJetty(AbstractJettyRunTask.java:191) at org.gradle.api.plugins.jetty.AbstractJettyRunTask.start(AbstractJettyRunTask.java:162) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:63) at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:218) at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:211) at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:200) at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:579) at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:562) at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80) at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61) at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46) at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35) at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64) at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58) at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42) at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52) at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53) at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43) at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:305) at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79) at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63) at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51) at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:23) at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:88) at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:29) at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:62) at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23) at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:68) at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32) at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:62) at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:55) at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:149) at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:106) at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:86) at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:80) at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:33) at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:24) at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:36) at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:26) at org.gradle.launcher.cli.RunBuildAction.run(RunBuildAction.java:51) at org.gradle.internal.Actions$RunnableActionAdapter.execute(Actions.java:171) at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:237) at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:210) at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:35) at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:24) at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:206) at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:169) at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:33) at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:22) at org.gradle.launcher.Main.doAction(Main.java:33) at org.gradle.launcher.bootstrap.EntryPoint.run(EntryPoint.java:45) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.gradle.launcher.bootstrap.ProcessBootstrap.runNoExit(ProcessBootstrap.java:54) at org.gradle.launcher.bootstrap.ProcessBootstrap.run(ProcessBootstrap.java:35) at org.gradle.launcher.GradleMain.main(GradleMain.java:23) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.gradle.wrapper.BootstrapMainStarter.start(BootstrapMainStarter.java:30) at org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:127) at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:56) Caused by: groovy.lang.GroovyRuntimeException: Conflicting module versions. Module [groovy-all is loaded in version 2.3.6 and you are trying to load version 2.3.1 at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl$DefaultModuleListener.onModule(MetaClassRegistryImpl.java:509) at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanExtensionModuleFromProperties(ExtensionModuleScanner.java:78) at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanExtensionModuleFromMetaInf(ExtensionModuleScanner.java:72) at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanClasspathModules(ExtensionModuleScanner.java:54) at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:110) at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:71) at groovy.lang.GroovySystem.<clinit>(GroovySystem.java:33)  105 more Building remains at 90% and when I query localhost:8080 I get a Jetty error page. Am I doing something wrong? I've read that Jetty plugin is somewhat outdated so it may be using and older version of groovy-all module config-file source-file source-file source-file source-file",no-bug,0.95
