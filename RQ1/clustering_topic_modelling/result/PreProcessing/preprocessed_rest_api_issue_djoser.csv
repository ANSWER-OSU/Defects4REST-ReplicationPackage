issue_no,repo,issue_url,title,description,patched_file_types,text_for_topic_modeling,prediction,confidence,combined_text
413,djoser,https://github.com/sunscrapers/djoser/issues/413,AttributeError at /api/auth/users/,"I tried to create a new user by running a POST request to `/api/auth/users/`. User created and email sended, but with error:  Got AttributeError when attempting to get a value for field `re_password` on serializer `UserCreatePasswordRetypeSerializer`. The serializer field might be named incorrectly and not match any attribute or key on the `User` instance. Original exception text was: 'User' object has no attribute 're_password'.   Environment: Request Method: POST Request URL: http://api.localhost/api/auth/users/ Django Version: 2.2.3 Python Version: 3.7.3 Installed Applications: ['corsheaders', 'django_filters', 'mptt', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'django.contrib.sites', 'rest_framework', 'rest_framework.authtoken', 'djoser', 'debug_toolbar'] Installed Middleware: ['debug_toolbar.middleware.DebugToolbarMiddleware', 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'django_currentuser.middleware.ThreadLocalUserMiddleware'] Traceback: File ""/usr/local/lib/python3.7/site-packages/rest_framework/fields.py"" in get_attribute 443. return get_attribute(instance, self.source_attrs) File ""/usr/local/lib/python3.7/site-packages/rest_framework/fields.py"" in get_attribute 93. instance = getattr(instance, attr) During handling of the above exception ('User' object has no attribute 're_password'), another exception occurred: File ""/usr/local/lib/python3.7/site-packages/django/core/handlers/exception.py"" in inner 34. response = get_response(request) File ""/usr/local/lib/python3.7/site-packages/django/core/handlers/base.py"" in _get_response 115. response = self.process_exception_by_middleware(e, request) File ""/usr/local/lib/python3.7/site-packages/django/core/handlers/base.py"" in _get_response 113. response = wrapped_callback(request, *callback_args, **callback_kwargs) File ""/usr/local/lib/python3.7/site-packages/django/views/decorators/csrf.py"" in wrapped_view 54. return view_func(*args, **kwargs) File ""/usr/local/lib/python3.7/site-packages/rest_framework/viewsets.py"" in view 114. return self.dispatch(request, *args, **kwargs) File ""/usr/local/lib/python3.7/site-packages/rest_framework/views.py"" in dispatch 497. response = self.handle_exception(exc) File ""/usr/local/lib/python3.7/site-packages/rest_framework/views.py"" in handle_exception 457. self.raise_uncaught_exception(exc) File ""/usr/local/lib/python3.7/site-packages/rest_framework/views.py"" in raise_uncaught_exception 468. raise exc File ""/usr/local/lib/python3.7/site-packages/rest_framework/views.py"" in dispatch 494. response = handler(request, *args, **kwargs) File ""/usr/local/lib/python3.7/site-packages/rest_framework/mixins.py"" in create 20. headers = self.get_success_headers(serializer.data) File ""/usr/local/lib/python3.7/site-packages/rest_framework/serializers.py"" in data 559. ret = super().data File ""/usr/local/lib/python3.7/site-packages/rest_framework/serializers.py"" in data 261. self._data = self.to_representation(self.instance) File ""/usr/local/lib/python3.7/site-packages/rest_framework/serializers.py"" in to_representation 513. attribute = field.get_attribute(instance) File ""/usr/local/lib/python3.7/site-packages/rest_framework/fields.py"" in get_attribute 476. raise type(exc)(msg) Exception Type: AttributeError at /api/auth/users/ Exception Value: Got AttributeError when attempting to get a value for field `re_password` on serializer `UserCreatePasswordRetypeSerializer`. The serializer field might be named incorrectly and not match any attribute or key on the `User` instance. Original exception text was: 'User' object has no attribute 're_password'.  settings.py python DJOSER = { 'ACTIVATION_URL': '#/activate/{uid}/{token}', 'PASSWORD_RESET_CONFIRM_RETYPE': True, 'PASSWORD_RESET_CONFIRM_URL': '#/password/reset/confirm/{uid}/{token}', 'SEND_ACTIVATION_EMAIL': True, 'SEND_CONFIRMATION_EMAIL': True, 'USER_CREATE_PASSWORD_RETYPE': True, }  User Model python class User(AbstractUser): USERNAME_FIELD = 'email' REQUIRED_FIELDS = [] username = None email = models.EmailField('Email', unique=True) company = models.ForeignKey(Company, on_delete=models.CASCADE, null=True, blank=True) objects = IMSUserManager()  UserManager, rewrite without username python class IMSUserManager(BaseUserManager): use_in_migrations = True def _create_user(self, email, password, **extra_fields):  Create and save a user with the given username, email, and password.  if not email: raise ValueError('The given email must be set') email = self.normalize_email(email) user = self.model(email=email, **extra_fields) user.set_password(password) user.save(using=self._db) return user def create_user(self, email=None, password=None, **extra_fields): extra_fields.setdefault('is_staff', False) extra_fields.setdefault('is_superuser', False) return self._create_user(email, password, **extra_fields) def create_superuser(self, email, password, **extra_fields): extra_fields.setdefault('is_staff', True) extra_fields.setdefault('is_superuser', True) if extra_fields.get('is_staff') is not True: raise ValueError('Superuser must have is_staff=True.') if extra_fields.get('is_superuser') is not True: raise ValueError('Superuser must have is_superuser=True.') return self._create_user(email, password, **extra_fields) ",documentation-file | source-file | source-file | source-file | source-file | test-file | documentation-file | source-file | source-file | source-file | source-file | test-file,attributeerror api auth users tried create new user running post api auth users user created email sended got attributeerror attempting get value field password serializer usercreatepasswordretypeserializer serializer field might named incorrectly match attribute key user instance original exception text user object attribute password environment method post url http api localhost api auth users django python installed applications corsheaders django filters mptt django contrib admin django contrib auth django contrib contenttypes django contrib sessions django contrib messages django contrib staticfiles django contrib sites rest framework rest framework authtoken toolbar installed middleware toolbar middleware debugtoolbarmiddleware django middleware security securitymiddleware django contrib sessions middleware sessionmiddleware corsheaders middleware corsmiddleware django middleware common commonmiddleware django middleware csrf csrfviewmiddleware django contrib auth middleware authenticationmiddleware django contrib messages middleware messagemiddleware django middleware clickjacking xframeoptionsmiddleware django currentuser middleware threadlocalusermiddleware traceback local python site packages rest framework fields get attribute return get attribute instance self attrs local python site packages rest framework fields get attribute instance getattr instance attr handling exception user object attribute password another exception occurred local python site packages django core handlers exception inner response get response local python site packages django core handlers base get response response self process exception middleware local python site packages django core handlers base get response response wrapped callback callback args callback kwargs local python site packages django views decorators csrf wrapped view return view func args kwargs local python site packages rest framework viewsets view return self dispatch args kwargs local python site packages rest framework views dispatch response self handle exception exc local python site packages rest framework views handle exception self raise uncaught exception exc local python site packages rest framework views raise uncaught exception raise exc local python site packages rest framework views dispatch response handler args kwargs local python site packages rest framework mixins create headers self get success headers serializer data local python site packages rest framework serializers data ret super data local python site packages rest framework serializers data self data self representation self instance local python site packages rest framework serializers representation attribute field get attribute instance local python site packages rest framework fields get attribute raise type exc msg exception type attributeerror api auth users exception value got attributeerror attempting get value field password serializer usercreatepasswordretypeserializer serializer field might named incorrectly match attribute key user instance original exception text user object attribute password settings python activation url activate uid token password reset confirm retype true password reset confirm url password reset confirm uid token send activation email true send confirmation email true user create password retype true user model python class user abstractuser username field email required fields username none email models emailfield email unique true company models foreignkey company delete models cascade null true blank true objects imsusermanager usermanager rewrite without username python class imsusermanager baseusermanager use migrations true def create user self email password extra fields create save user given username email password email raise valueerror given email must set email self normalize email email user self model email email extra fields user set password password user save self return user def create user self email none password none extra fields extra fields setdefault staff false extra fields setdefault superuser false return self create user email password extra fields def create superuser self email password extra fields extra fields setdefault staff true extra fields setdefault superuser true extra fields get staff true raise valueerror superuser must staff true extra fields get superuser true raise valueerror superuser must superuser true return self create user email password extra fields,bug,0.95,"AttributeError at /api/auth/users/ I tried to create a new user by running a POST request to `/api/auth/users/`. User created and email sended, but with error:  Got AttributeError when attempting to get a value for field `re_password` on serializer `UserCreatePasswordRetypeSerializer`. The serializer field might be named incorrectly and not match any attribute or key on the `User` instance. Original exception text was: 'User' object has no attribute 're_password'.   Environment: Request Method: POST Request URL: http://api.localhost/api/auth/users/ Django Version: 2.2.3 Python Version: 3.7.3 Installed Applications: ['corsheaders', 'django_filters', 'mptt', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'django.contrib.sites', 'rest_framework', 'rest_framework.authtoken', 'djoser', 'debug_toolbar'] Installed Middleware: ['debug_toolbar.middleware.DebugToolbarMiddleware', 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'django_currentuser.middleware.ThreadLocalUserMiddleware'] Traceback: File ""/usr/local/lib/python3.7/site-packages/rest_framework/fields.py"" in get_attribute 443. return get_attribute(instance, self.source_attrs) File ""/usr/local/lib/python3.7/site-packages/rest_framework/fields.py"" in get_attribute 93. instance = getattr(instance, attr) During handling of the above exception ('User' object has no attribute 're_password'), another exception occurred: File ""/usr/local/lib/python3.7/site-packages/django/core/handlers/exception.py"" in inner 34. response = get_response(request) File ""/usr/local/lib/python3.7/site-packages/django/core/handlers/base.py"" in _get_response 115. response = self.process_exception_by_middleware(e, request) File ""/usr/local/lib/python3.7/site-packages/django/core/handlers/base.py"" in _get_response 113. response = wrapped_callback(request, *callback_args, **callback_kwargs) File ""/usr/local/lib/python3.7/site-packages/django/views/decorators/csrf.py"" in wrapped_view 54. return view_func(*args, **kwargs) File ""/usr/local/lib/python3.7/site-packages/rest_framework/viewsets.py"" in view 114. return self.dispatch(request, *args, **kwargs) File ""/usr/local/lib/python3.7/site-packages/rest_framework/views.py"" in dispatch 497. response = self.handle_exception(exc) File ""/usr/local/lib/python3.7/site-packages/rest_framework/views.py"" in handle_exception 457. self.raise_uncaught_exception(exc) File ""/usr/local/lib/python3.7/site-packages/rest_framework/views.py"" in raise_uncaught_exception 468. raise exc File ""/usr/local/lib/python3.7/site-packages/rest_framework/views.py"" in dispatch 494. response = handler(request, *args, **kwargs) File ""/usr/local/lib/python3.7/site-packages/rest_framework/mixins.py"" in create 20. headers = self.get_success_headers(serializer.data) File ""/usr/local/lib/python3.7/site-packages/rest_framework/serializers.py"" in data 559. ret = super().data File ""/usr/local/lib/python3.7/site-packages/rest_framework/serializers.py"" in data 261. self._data = self.to_representation(self.instance) File ""/usr/local/lib/python3.7/site-packages/rest_framework/serializers.py"" in to_representation 513. attribute = field.get_attribute(instance) File ""/usr/local/lib/python3.7/site-packages/rest_framework/fields.py"" in get_attribute 476. raise type(exc)(msg) Exception Type: AttributeError at /api/auth/users/ Exception Value: Got AttributeError when attempting to get a value for field `re_password` on serializer `UserCreatePasswordRetypeSerializer`. The serializer field might be named incorrectly and not match any attribute or key on the `User` instance. Original exception text was: 'User' object has no attribute 're_password'.  settings.py python DJOSER = { 'ACTIVATION_URL': '#/activate/{uid}/{token}', 'PASSWORD_RESET_CONFIRM_RETYPE': True, 'PASSWORD_RESET_CONFIRM_URL': '#/password/reset/confirm/{uid}/{token}', 'SEND_ACTIVATION_EMAIL': True, 'SEND_CONFIRMATION_EMAIL': True, 'USER_CREATE_PASSWORD_RETYPE': True, }  User Model python class User(AbstractUser): USERNAME_FIELD = 'email' REQUIRED_FIELDS = [] username = None email = models.EmailField('Email', unique=True) company = models.ForeignKey(Company, on_delete=models.CASCADE, null=True, blank=True) objects = IMSUserManager()  UserManager, rewrite without username python class IMSUserManager(BaseUserManager): use_in_migrations = True def _create_user(self, email, password, **extra_fields):  Create and save a user with the given username, email, and password.  if not email: raise ValueError('The given email must be set') email = self.normalize_email(email) user = self.model(email=email, **extra_fields) user.set_password(password) user.save(using=self._db) return user def create_user(self, email=None, password=None, **extra_fields): extra_fields.setdefault('is_staff', False) extra_fields.setdefault('is_superuser', False) return self._create_user(email, password, **extra_fields) def create_superuser(self, email, password, **extra_fields): extra_fields.setdefault('is_staff', True) extra_fields.setdefault('is_superuser', True) if extra_fields.get('is_staff') is not True: raise ValueError('Superuser must have is_staff=True.') if extra_fields.get('is_superuser') is not True: raise ValueError('Superuser must have is_superuser=True.') return self._create_user(email, password, **extra_fields) "
374,djoser,https://github.com/sunscrapers/djoser/issues/374,Documentation Issue - jwt verification endpoint,"The /auth/jwt/verify endpoint throws a 401 unauthorised error, and not a 400. <img width=""1166"" alt=""Screenshot 2019-05-02 at 16 52 06"" src=""https://user-images.githubusercontent.com/23339706/57088747-daccf600-6cfa-11e9-9809-7b4fd9279bc6.png"">",documentation-file | source-file | documentation-file | documentation-file | source-file,documentation jwt verification endpoint auth jwt verify endpoint throws unauthorised img width alt screenshot https user images githubusercontent daccf cfa png,bug,0.9,"Documentation Issue - jwt verification endpoint The /auth/jwt/verify endpoint throws a 401 unauthorised error, and not a 400. <img width=""1166"" alt=""Screenshot 2019-05-02 at 16 52 06"" src=""https://user-images.githubusercontent.com/23339706/57088747-daccf600-6cfa-11e9-9809-7b4fd9279bc6.png"">"
42,djoser,https://github.com/sunscrapers/djoser/issues/42,Username is not validated properly for `set_username` endpoint,To be precise the issue is caused by function called `create_username_field()`. It creates the serializer field but it doesn't add the validators to this field instance. It just doesn't take into account the parameters passed to username model field.,source-file | test-file | test-file | test-file,username validated properly set username endpoint precise caused function called create username field creates serializer field validators field instance take account parameters passed username model field,bug,0.9,Username is not validated properly for `set_username` endpoint To be precise the issue is caused by function called `create_username_field()`. It creates the serializer field but it doesn't add the validators to this field instance. It just doesn't take into account the parameters passed to username model field.
417,djoser,https://github.com/sunscrapers/djoser/issues/417,"user ""delete"" permissions and serializer settings not respected","The permission_class setting for ""user_delete"" is not respected as `UserViewSet.get_permissions` doesn't check for action `delete` or (`me` with method `DELETE`). Instead, it just uses the default class permission. Also the `UserViewSet.get_serializer_class` doesn't work for `user_delete` as the action that is checked is `remove` while the real action should be `delete`. This serializer setting is important as out-of-the-box it requires the user's password before deleting.",source-file | source-file | source-file | test-file | test-file | source-file | source-file | source-file | test-file | test-file,user delete permissions serializer settings respected permission class setting user delete respected userviewset get permissions check action delete method delete instead uses default class permission also userviewset get serializer class work user delete action checked real action delete serializer setting important box requires user password deleting,bug,0.9,"user ""delete"" permissions and serializer settings not respected The permission_class setting for ""user_delete"" is not respected as `UserViewSet.get_permissions` doesn't check for action `delete` or (`me` with method `DELETE`). Instead, it just uses the default class permission. Also the `UserViewSet.get_serializer_class` doesn't work for `user_delete` as the action that is checked is `remove` while the real action should be `delete`. This serializer setting is important as out-of-the-box it requires the user's password before deleting."
327,djoser,https://github.com/sunscrapers/djoser/issues/327,403 error on user requests," Steps to Reproduce: 1. Sign into a non-administrative user 2. Attempt to retrieve another user from `GET /auth/users/:userid/`  Expected results: The user is sent back.  Actual results: 403 error. This was broken by https://github.com/sunscrapers/djoser/commit/0d36af98ac26691678ac11b91d4b04c2e0e59a69. It completely restricts access to other users, rather than limiting it to read-only.",documentation-file | source-file | source-file | source-file | documentation-file | test-file | documentation-file | source-file | source-file | source-file | documentation-file | test-file,user requests steps reproduce sign non administrative user attempt retrieve another user get auth users userid expected results user sent back actual results broken https github sunscrapers completely restricts access users rather limiting read,bug,0.95,"403 error on user requests  Steps to Reproduce: 1. Sign into a non-administrative user 2. Attempt to retrieve another user from `GET /auth/users/:userid/`  Expected results: The user is sent back.  Actual results: 403 error. This was broken by https://github.com/sunscrapers/djoser/commit/0d36af98ac26691678ac11b91d4b04c2e0e59a69. It completely restricts access to other users, rather than limiting it to read-only."
430,djoser,https://github.com/sunscrapers/djoser/issues/430,User activation logic does not follow docs,"According to [the docs](https://djoser.readthedocs.io/en/latest/settings.html#send-activation-email), a user is ""required to click activation link sent in email"" after updating their email. This is not happening and further research into the code reveals this different logic: https://github.com/sunscrapers/djoser/blob/c5a6f85efb55bc569529c45d98d3992f7ff7fc8b/djoser/views.py#L152 Could you please either patch this or update the docs?",source-file | source-file | source-file,user activation logic follow docs according docs https readthedocs latest settings html send activation email user required click activation link sent email updating email happening research reveals different logic https github sunscrapers blob efb views could please either docs,bug,0.9,"User activation logic does not follow docs According to [the docs](https://djoser.readthedocs.io/en/latest/settings.html#send-activation-email), a user is ""required to click activation link sent in email"" after updating their email. This is not happening and further research into the code reveals this different logic: https://github.com/sunscrapers/djoser/blob/c5a6f85efb55bc569529c45d98d3992f7ff7fc8b/djoser/views.py#L152 Could you please either patch this or update the docs?"
795,djoser,https://github.com/sunscrapers/djoser/issues/795,DJOSER is giving tokens to users that don't pass the AUTHENTICATION_BACKENDS.authenticate,"https://github.com/sunscrapers/djoser/blob/4452009f628b59f02704373d5e7f991f1243397f/djoser/serializers.py#L127 When retrieving a token DJOSER check itself if the password match, or not. If password match, only active or not validation is done. Django authentication backends propose a set of method to do authentication centralised by backend, while respecting the configuration order (first login accepted first groups and permissions given to the user). django.contrib.auth.authenticate is used in AUTHENTICATION_BACKENDShttps://github.com/sunscrapers/djoser/blob/4452009f628b59f02704373d5e7f991f1243397f/djoser/serializers.py#L122. This function call, in the order declared in AUTHENTICATION_BACKENDS, the authenticate method for each backend. After checking if the login is correct in all authentication backends, if one user without any permission to get token has a user -password that match, DJOSE give the token. DJOSER should accept the result of authenticate because developpers can add more condition in the backends to allow user be authenticated.",test-file | other-file | other-file | config-file,giving tokens users pass authentication backends authenticate https github sunscrapers blob serializers retrieving token check password match password match active validation done django authentication backends propose set method authentication centralised backend respecting configuration order first login accepted first groups permissions given user django contrib auth authenticate used authentication backendshttps github sunscrapers blob serializers function call order declared authentication backends authenticate method backend checking login correct authentication backends one user without permission get token user password match djose give token accept result authenticate developpers condition backends allow user authenticated,bug,0.85,"DJOSER is giving tokens to users that don't pass the AUTHENTICATION_BACKENDS.authenticate https://github.com/sunscrapers/djoser/blob/4452009f628b59f02704373d5e7f991f1243397f/djoser/serializers.py#L127 When retrieving a token DJOSER check itself if the password match, or not. If password match, only active or not validation is done. Django authentication backends propose a set of method to do authentication centralised by backend, while respecting the configuration order (first login accepted first groups and permissions given to the user). django.contrib.auth.authenticate is used in AUTHENTICATION_BACKENDShttps://github.com/sunscrapers/djoser/blob/4452009f628b59f02704373d5e7f991f1243397f/djoser/serializers.py#L122. This function call, in the order declared in AUTHENTICATION_BACKENDS, the authenticate method for each backend. After checking if the login is correct in all authentication backends, if one user without any permission to get token has a user -password that match, DJOSE give the token. DJOSER should accept the result of authenticate because developpers can add more condition in the backends to allow user be authenticated."
120,djoser,https://github.com/sunscrapers/djoser/issues/120,Activation token invalidated by user login,"Hello, thanks for the great work on this library! `ActivationView` uses Django's `PasswordResetTokenGenerator` to generate the activation token. To create this token, this class hashes internal user state, including the user's last login time. This means if the user logs in before clicking the activation link (in situations where the activation link is sent, but the user is not required to click it before logging in), the token is invalidated and will not work. The API returns a 400 with `INVALID_TOKEN_ERROR`. This token hashing behavior makes sense for password reset tokens, however when creating activation tokens we should not hash the user's last login. This will allow djoser to support optional activation/confirmation links. What are your thoughts on this? Would you be willing to accept a pull request?",documentation-file | source-file | source-file | source-file | source-file | test-file | test-file,activation token invalidated user login hello thanks great work library activationview uses django passwordresettokengenerator generate activation token create token class hashes internal user state including user last login time means user logs clicking activation link situations activation link sent user required click logging token invalidated work api returns invalid token token hashing behavior makes sense password reset tokens however creating activation tokens hash user last login allow optional activation confirmation links thoughts would willing accept,bug,0.85,"Activation token invalidated by user login Hello, thanks for the great work on this library! `ActivationView` uses Django's `PasswordResetTokenGenerator` to generate the activation token. To create this token, this class hashes internal user state, including the user's last login time. This means if the user logs in before clicking the activation link (in situations where the activation link is sent, but the user is not required to click it before logging in), the token is invalidated and will not work. The API returns a 400 with `INVALID_TOKEN_ERROR`. This token hashing behavior makes sense for password reset tokens, however when creating activation tokens we should not hash the user's last login. This will allow djoser to support optional activation/confirmation links. What are your thoughts on this? Would you be willing to accept a pull request?"
190,djoser,https://github.com/sunscrapers/djoser/issues/190,Race condition in case of near simultaneous POST API calls,"Some of Djoser views are vulnerable to a race condition (which is not really a security issue unless you've setup debug in production). Basically saying, the problem is that in case of near simultaneous requests to endpoint with a POST method, which creates object for a model with a field with unique constraint, it will result in an `IntegrityError` and will return 500 to the client. It happens because of mentioned race condition, where validation step passes for both requests and than it fails on transaction to database.",source-file | source-file | source-file | test-file | source-file | source-file | source-file | test-file,race condition case near simultaneous post api calls views vulnerable race condition really security unless setup production basically saying case near simultaneous requests endpoint post method creates object model field unique constraint result integrityerror return client happens mentioned race condition validation step passes requests fails transaction database,bug,0.9,"Race condition in case of near simultaneous POST API calls Some of Djoser views are vulnerable to a race condition (which is not really a security issue unless you've setup debug in production). Basically saying, the problem is that in case of near simultaneous requests to endpoint with a POST method, which creates object for a model with a field with unique constraint, it will result in an `IntegrityError` and will return 500 to the client. It happens because of mentioned race condition, where validation step passes for both requests and than it fails on transaction to database."
5,djoser,https://github.com/sunscrapers/djoser/issues/5,AssertionError at /auth/logout," AssertionError at /auth/logout 'LogoutView' should either include a 'serializer_class' attribute, or use the 'model' attribute as a shortcut for automatically generating a serializer class.  i think this is due to a change in DRF. Here are my versions:  Django==1.6.8 djoser==0.1.0 djangorestframework==2.4.4  Pull request with a fix incoming",source-file,assertionerror auth logout assertionerror auth logout logoutview either include serializer class attribute use model attribute shortcut automatically generating serializer class think due drf versions django djangorestframework incoming,bug,0.9,"AssertionError at /auth/logout  AssertionError at /auth/logout 'LogoutView' should either include a 'serializer_class' attribute, or use the 'model' attribute as a shortcut for automatically generating a serializer class.  i think this is due to a change in DRF. Here are my versions:  Django==1.6.8 djoser==0.1.0 djangorestframework==2.4.4  Pull request with a fix incoming"
323,djoser,https://github.com/sunscrapers/djoser/issues/323,'UserView' should either include a `queryset` attribute," Request Method: | GET -- | -- http://127.0.0.1:8000/api/v1/auth/me 2.1.3 AssertionError 'UserView' should either include a `queryset` attribute, or override the `get_queryset()` method. C:\Python37\lib\site-packages\rest_framework\generics.py in get_queryset, line 68 C:\Python37\python.exe  Related commit https://github.com/encode/django-rest-framework/commit/b3253b42836acd123224e88c0927f1ee6a031d94",documentation-file | source-file | source-file | source-file,userview either include queryset attribute method get http api auth assertionerror userview either include queryset attribute override get queryset method python site packages rest framework generics get queryset python python exe related https github encode django rest framework acd,bug,0.9,"'UserView' should either include a `queryset` attribute  Request Method: | GET -- | -- http://127.0.0.1:8000/api/v1/auth/me 2.1.3 AssertionError 'UserView' should either include a `queryset` attribute, or override the `get_queryset()` method. C:\Python37\lib\site-packages\rest_framework\generics.py in get_queryset, line 68 C:\Python37\python.exe  Related commit https://github.com/encode/django-rest-framework/commit/b3253b42836acd123224e88c0927f1ee6a031d94"
