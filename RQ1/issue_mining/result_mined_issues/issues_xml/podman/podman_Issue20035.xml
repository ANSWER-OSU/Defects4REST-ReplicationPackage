<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>20035</ISSUENO>
  <ISSUEURL>https://github.com/containers/podman/issues/20035</ISSUEURL>
  <TITLE>Listing networks via Docker compat is far slower than Docker</TITLE>
  <DESCRIPTION>### Issue Description Listing networks via the docker compat support is disproportionally slower than docker's support. In our case, it's slow enough (becomes multiple seconds) that we may have to switch to docker. ### Steps to reproduce the issue Test Case: Requires python 3.11 and python packages: * pytest * pytest-mocker * docker ```python import contextlib import dataclasses import os import tempfile import time import typing import docker def get_client(): return docker.from_env() @dataclasses.dataclass class Dind: image: str cmd: typing.Optional[list[str]] @contextlib.contextmanager def dind_factory(dind: Dind): tmp_folder = tempfile.TemporaryDirectory() client = docker.from_env() container = client.containers.run( dind.image, dind.cmd, detach=True, privileged=True, user=os.getuid(), volumes=[f&quot;{tmp_folder.name}:/sockets&quot;], environment={&quot;XDG_RUNTIME_DIR&quot;: &quot;/sockets&quot;}, remove=True, ) while True: try: dind_client = docker.from_env(timeout=1) dind_client.images.pull(&quot;quay.io/podman/hello&quot;) dind_client.containers.run(&quot;quay.io/podman/hello&quot;) except Exception: continue break try: yield f&quot;unix://{tmp_folder.name}/docker.sock&quot; finally: # Clear up Containers container.remove(force=True) tmp_folder.cleanup() def test_network_list_performance(mocker): def test(): client = get_client() client.images.pull(&quot;docker.io/library/busybox:latest&quot;) for i in range(25): client.networks.create(f&quot;net{i}&quot;) client.containers.run( &quot;docker.io/library/busybox:latest&quot;, [&quot;sleep&quot;, &quot;100000&quot;], network=f&quot;net{i}&quot;, detach=True, ) client.containers.run( &quot;docker.io/library/busybox:latest&quot;, [&quot;sleep&quot;, &quot;100000&quot;], network=f&quot;net{i}&quot;, detach=True, ) client.containers.run( &quot;docker.io/library/busybox:latest&quot;, [&quot;sleep&quot;, &quot;100000&quot;], network=f&quot;net{i}&quot;, detach=True, ) client.containers.run( &quot;docker.io/library/busybox:latest&quot;, [&quot;sleep&quot;, &quot;100000&quot;], network=f&quot;net{i}&quot;, detach=True, ) before_time = time.time() client.networks.list(filters=dict(driver=&quot;bridge&quot;)) return time.time() - before_time with dind_factory( Dind( &quot;quay.io/podman/stable&quot;, [&quot;podman&quot;, &quot;system&quot;, &quot;service&quot;, &quot;--time=0&quot;, &quot;unix:///sockets/docker.sock&quot;], ) ) as unix_socket: mocker.patch.dict(os.environ, {&quot;DOCKER_HOST&quot;: unix_socket}) podman_before = time.time() podman_execution_time = test() print(f&quot;Podman overall setup: {time.time() - podman_before}&quot;) del os.environ[&quot;DOCKER_HOST&quot;] with dind_factory(Dind(&quot;docker:dind-rootless&quot;, None)) as unix_socket: mocker.patch.dict(os.environ, {&quot;DOCKER_HOST&quot;: unix_socket}) docker_before = time.time() docker_execution_time = test() print(f&quot;Docker overall setup: {time.time() - docker_before}&quot;) assert podman_execution_time &lt;= docker_execution_time ``` Run via `pytest &lt;location of test file&gt;`. (written with linux in mind, with a local instance of docker running) It launches podman and docker in containers, creates 25 networks each with 4 containers and monitors how long it takes to list networks (and cleans up after itself). On my system, this test case takes ~1.5 seconds to list networks via docker compat and 0.003 seconds via docker. ### Describe the results you received In the above test case (which in terms of container arrangement is roughly to our software with light usage), listing networks via podman's docker compat layer is far slower than docker and gets disproportionally worse with more networks/containers. 0.24 seconds vs 0.002 seconds (10 networks, each with 4 containers) 1.5 seconds vs 0.003 seconds (25 networks, each with 4 containers) ### Describe the results you expected I'd expect podmans's docker network support to be comparable to docker's. Our issue is that we can create many hundreds of networks with multiple containers each (we're managing IPAM manually to enable this), so podman's docker network listing becomes too slow for us to use and we may have to switch to docker if it can't be sped up. (Python doesn't have an async podman library yet, so switching to podman without the docker company layer isn't an option). ### podman info output ```yaml host: arch: amd64 buildahVersion: 1.30.0 cgroupControllers: - cpuset - cpu - cpuacct - blkio - memory - devices - freezer - net_cls - perf_event - net_prio - hugetlb - pids - rdma cgroupManager: cgroupfs cgroupVersion: v1 conmon: package: conmon-2.1.7-r1 path: /usr/bin/conmon version: 'conmon version 2.1.7, commit: unknown' cpuUtilization: idlePercent: 70.74 systemPercent: 6.86 userPercent: 22.39 cpus: 8 databaseBackend: boltdb distribution: distribution: alpine version: 3.18.3 eventLogger: file hostname: bbbca290abcd idMappings: gidmap: null uidmap: null kernel: 5.4.0-162-generic linkmode: dynamic logDriver: k8s-file memFree: 1470201856 memTotal: 16508235776 networkBackend: netavark ociRuntime: name: crun package: crun-1.8.4-r0 path: /usr/bin/crun version: |- crun version 1.8.4 commit: 5a8fa99a5e41facba2eda4af12fa26313918805b rundir: /run/crun spec: 1.0.0 +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +YAJL os: linux remoteSocket: path: /run/podman/podman.sock security: apparmorEnabled: false capabilities: CAP_CHOWN,CAP_DAC_OVERRIDE,CAP_FOWNER,CAP_FSETID,CAP_KILL,CAP_NET_BIND_SERVICE,CAP_SETFCAP,CAP_SETGID,CAP_SETPCAP,CAP_SETUID,CAP_SYS_CHROOT rootless: false seccompEnabled: true seccompProfilePath: /etc/containers/seccomp.json selinuxEnabled: false serviceIsRemote: false slirp4netns: executable: /usr/bin/slirp4netns package: slirp4netns-1.2.0-r0 version: |- slirp4netns version 1.2.0 commit: 656041d45cfca7a4176f6b7eed9e4fe6c11e8383 libslirp: 4.7.0 SLIRP_CONFIG_VERSION_MAX: 4 libseccomp: 2.5.4 swapFree: 14555238400 swapTotal: 17179865088 uptime: 32h 22m 32.00s (Approximately 1.33 days) plugins: authorization: null log: - k8s-file - none - passthrough network: - bridge - macvlan - ipvlan volume: - local registries: search: - docker.io store: configFile: /etc/containers/storage.conf containerStore: number: 0 paused: 0 running: 0 stopped: 0 graphDriverName: overlay graphOptions: overlay.mountopt: nodev graphRoot: /var/lib/containers/storage graphRootAllocated: 500619575296 graphRootUsed: 352948707328 graphStatus: Backing Filesystem: overlayfs Native Overlay Diff: &quot;false&quot; Supports d_type: &quot;true&quot; Using metacopy: &quot;false&quot; imageCopyTmpDir: /var/tmp imageStore: number: 8 runRoot: /run/containers/storage transientStore: false volumePath: /var/lib/containers/storage/volumes version: APIVersion: 4.5.1 Built: 1694067067 BuiltTime: Thu Sep 7 06:11:07 2023 GitCommit: &quot;&quot; GoVersion: go1.20.8 Os: linux OsArch: linux/amd64 Version: 4.5.1 ``` ### Podman in a container Yes ### Privileged Or Rootless Privileged ### Upstream Latest Release No ### Additional environment details We're installing/using podman in an alpine 3.18 privileged container (with fuse-overlayfs). ### Additional information _No response_</DESCRIPTION>
  <REPONAME>podman</REPONAME>
  <TIMEDIFFERENCEDAYS>0</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>libpod: remove unused ContainerState() fucntion First that function claims to deep copy but then actually return the original state so it does not work correctly, given that there are no users just remove it instead of fixing it. Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
    <SHA>befdb41995ca39a94203413ee2ab5f516e5cf56b</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>compat API: speed up network list The network list compat API requires us to include all containers with their ip addresses for the selected networks. Because we have no network -&gt; container mapping in the db we have to go through all containers every time. However the old code did it in the most ineffective way possible, it quered the containers from the db for each individual network. The of course is extremely expensive. Now the other expensive call is calling Inspect() on the container each time. Inspect does for more than we need. To fix this we fist query containers only once for the API call, then replace the inspect call with directly accessing the network status. This will speed things up a lot! The reported scenario includes 100 containers and 25 networks, previously it took 1.5s for the API call not it takes 24ms, that is a more than a 62x improvement. (tested with curl) [NO NEW TESTS NEEDED] We have no timing tests. Fixes #20035 Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
      <SHA>8e5adde0b3f60cec75904458d36ed79be83aea38</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container.go</FILE>
        <FILE>pkg/api/handlers/compat/networks.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>compat API: speed up network list The network list compat API requires us to include all containers with their ip addresses for the selected networks. Because we have no network -&gt; container mapping in the db we have to go through all containers every time. However the old code did it in the most ineffective way possible, it quered the containers from the db for each individual network. The of course is extremely expensive. Now the other expensive call is calling Inspect() on the container each time. Inspect does for more than we need. To fix this we fist query containers only once for the API call, then replace the inspect call with directly accessing the network status. This will speed things up a lot! The reported scenario includes 100 containers and 25 networks, previously it took 1.5s for the API call not it takes 24ms, that is a more than a 62x improvement. (tested with curl) [NO NEW TESTS NEEDED] We have no timing tests. Fixes #20035 Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
      <SHA>456450438744455e906ace56f127604629812400</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container.go</FILE>
        <FILE>pkg/api/handlers/compat/networks.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
