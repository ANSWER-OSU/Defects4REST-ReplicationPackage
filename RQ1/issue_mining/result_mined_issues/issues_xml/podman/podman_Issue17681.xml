<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>17681</ISSUENO>
  <ISSUEURL>https://github.com/containers/podman/issues/17681</ISSUEURL>
  <TITLE>'--ulimit host' permits more open files in the container</TITLE>
  <DESCRIPTION>### Issue Description Compare: ``` [rishi@topinka ~]$ podman run -it --rm --env TERM=$TERM --ulimit host \ registry.fedoraproject.org/fedora:38 ulimit -n 524288 [rishi@topinka ~]$ ulimit -n 1024 ``` Or: ``` [rishi@topinka ~]$ podman run -it --rm --env TERM=$TERM --ulimit host \ registry.fedoraproject.org/fedora:38 ulimit -a real-time non-blocking time (microseconds, -R) unlimited core file size (blocks, -c) unlimited data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 127760 max locked memory (kbytes, -l) 8192 max memory size (kbytes, -m) unlimited open files (-n) 524288 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 127760 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited ``` ... and: ``` [rishi@topinka ~]$ ulimit -a real-time non-blocking time (microseconds, -R) unlimited core file size (blocks, -c) unlimited data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 127760 max locked memory (kbytes, -l) 8192 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 127760 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited ``` Is this expected? ### Steps to reproduce the issue Steps to reproduce the issue 1. *see above* ### Describe the results you received `ulimit -n` has a higher value inside the container than on the host. ### Describe the results you expected I expected `ulimit -n` to have the same value inside the container and on the host. ### podman info output ```yaml host: arch: amd64 buildahVersion: 1.29.0 cgroupControllers: - cpu - io - memory - pids cgroupManager: systemd cgroupVersion: v2 conmon: package: conmon-2.1.5-1.fc36.x86_64 path: /usr/bin/conmon version: 'conmon version 2.1.5, commit: ' cpuUtilization: idlePercent: 99.14 systemPercent: 0.16 userPercent: 0.7 cpus: 16 distribution: distribution: fedora variant: workstation version: &quot;36&quot; eventLogger: journald hostname: topinka idMappings: gidmap: - container_id: 0 host_id: 1000 size: 1 - container_id: 1 host_id: 100000 size: 65536 uidmap: - container_id: 0 host_id: 1000 size: 1 - container_id: 1 host_id: 100000 size: 65536 kernel: 6.1.14-100.fc36.x86_64 linkmode: dynamic logDriver: journald memFree: 22417584128 memTotal: 33553547264 networkBackend: netavark ociRuntime: name: crun package: crun-1.8-1.fc36.x86_64 path: /usr/bin/crun version: |- crun version 1.8 commit: 0356bf4aff9a133d655dc13b1d9ac9424706cac4 rundir: /run/user/1000/crun spec: 1.0.0 +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +WASM:wasmedge +YAJL os: linux remoteSocket: path: /run/user/1000/podman/podman.sock security: apparmorEnabled: false capabilities: CAP_CHOWN,CAP_DAC_OVERRIDE,CAP_FOWNER,CAP_FSETID,CAP_KILL,CAP_NET_BIND_SERVICE,CAP_SETFCAP,CAP_SETGID,CAP_SETPCAP,CAP_SETUID,CAP_SYS_CHROOT rootless: true seccompEnabled: true seccompProfilePath: /usr/share/containers/seccomp.json selinuxEnabled: true serviceIsRemote: false slirp4netns: executable: /usr/bin/slirp4netns package: slirp4netns-1.2.0-0.2.beta.0.fc36.x86_64 version: |- slirp4netns version 1.2.0-beta.0 commit: 477db14a24ff1a3de3a705e51ca2c4c1fe3dda64 libslirp: 4.6.1 SLIRP_CONFIG_VERSION_MAX: 3 libseccomp: 2.5.3 swapFree: 8589930496 swapTotal: 8589930496 uptime: 4h 26m 32.00s (Approximately 0.17 days) plugins: authorization: null log: - k8s-file - none - passthrough - journald network: - bridge - macvlan volume: - local registries: search: - registry.fedoraproject.org - registry.access.redhat.com - docker.io - quay.io store: configFile: /home/rishi/.config/containers/storage.conf containerStore: number: 7 paused: 0 running: 2 stopped: 5 graphDriverName: overlay graphOptions: {} graphRoot: /home/rishi/.local/share/containers/storage graphRootAllocated: 1695606808576 graphRootUsed: 262605983744 graphStatus: Backing Filesystem: extfs Native Overlay Diff: &quot;true&quot; Supports d_type: &quot;true&quot; Using metacopy: &quot;false&quot; imageCopyTmpDir: /var/tmp imageStore: number: 15 runRoot: /run/user/1000/containers transientStore: false volumePath: /home/rishi/.local/share/containers/storage/volumes version: APIVersion: 4.4.1 Built: 1676629882 BuiltTime: Fri Feb 17 11:31:22 2023 GitCommit: &quot;&quot; GoVersion: go1.18.10 Os: linux OsArch: linux/amd64 Version: 4.4.1 ``` ### Podman in a container No ### Privileged Or Rootless Rootless ### Upstream Latest Release Yes ### Additional environment details Fedora 36 Workstation ### Additional information _No response_</DESCRIPTION>
  <REPONAME>podman</REPONAME>
  <TIMEDIFFERENCEDAYS>4</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>Merge pull request #24227 from Luap99/ci-image-update cirrus: update CI images</MESSAGE>
    <SHA>d512e4414754a2ddda793d1fefe34cdb7ba88568</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>Don't bump RLIMIT_NOFILE in exec sessions with '--ulimit host' Starting from commit 9126b45a3f2255b1 (&quot;Up default Podman rlimits to avoid max open files&quot;), Podman started bumping its soft limit for the maximum number of open file descriptors (RLIMIT_NOFILE or ulimit -n) to permit exposing a large number of ports to a container. This was later fine-tuned in commit a2c1a2df54f3660c (&quot;podman: bump RLIMIT_NOFILE also without CAP_SYS_RESOURCE&quot;). Unfortunately, this also increases the limits for 'podman exec' sessions running in containers created with: $ podman create --network host --ulimit host ... This is what Toolbx uses to provide a containerized interactive command line environment for software development and troubleshooting the host operating system. It confuses developers and system administrators debugging a process that's leaking file descriptors and crashing on the host OS. The crashes either don't reproduce inside the container or they take a lot longer to reproduce, both of which are frustrating. Therefore, it will be good to retain the limits, at least for this specific scenario. It turns out that since this code was written, the Go runtime has had two interesting changes. Starting from Go 1.19 [1], the Go runtime bumps the soft limit for RLIMIT_NOFILE for all Go programs [2]. This means that there's no longer any need for Podman to bump it's own limits, because it switched from requiring Go 1.18 to 1.20 in commit 4dd58f226d937b83 (&quot;Move golang requirement from 1.18 to 1.20&quot;). It's probably good to still log the detected limits, in case Go's behaviour changes. Not everybody was happy with this [3], because the higher limits got propagated to child processes spawned by Go programs. Among other things, this can break old programs using select(2) [4]. So, Go's behaviour was fine-tuned to restore the original soft limit for RLIMIT_NOFILE when forking a child process [5]. With these two changes in Go, which Podman already uses, if the bumping of RLIMIT_NOFILE is left to the Go runtime, then the limits are no longer increased for 'podman exec' sessions. Otherwise, if Podman continues to bump the soft limit for RLIMIT_NOFILE on its own, then it prevents the Go runtime from restoring the original limits when forking, and leads to the higher limits in 'podman exec' sessions. The existing 'podman run --ulimit host ... ulimit -Hn' test in test/e2e/run_test.go was extended to also check the soft limit. The similar test for 'podman exec' was moved from test/e2e/toolbox_test.go to test/e2e/exec_test.go for consistency and because there's nothing Toolbx specific about it. The test was similarly extended, and updated to be more idiomatic. Due to the behaviour of the Go runtime noted above, and since the tests are written in Go, the current or soft limit for RLIMIT_NOFILE returned by syscall.Getrlimit() is the same as the hard limit. The Alpine Linux image doesn't have a standalone binary for 'ulimit' and it's picky about the order in which the options are listed. The -H or -S must come first, followed by a space, and then the -n. [1] https://go.dev/doc/go1.19#runtime [2] Go commit 8427429c592588af (&quot;os: raise open file rlimit at startup&quot;) https://github.com/golang/go/commit/8427429c592588af https://github.com/golang/go/issues/46279 [3] https://github.com/containerd/containerd/issues/8249 [4] http://0pointer.net/blog/file-descriptor-limits.html [5] Go commit f5eef58e4381259c (&quot;syscall: restore original NOFILE ...&quot;) https://github.com/golang/go/commit/f5eef58e4381259c https://github.com/golang/go/issues/46279 Fixes: https://github.com/containers/podman/issues/17681 Signed-off-by: Debarshi Ray &lt;rishi@fedoraproject.org&gt;</MESSAGE>
      <SHA>302d6383b0b5fd416c7a2b8f691329017f2ed669</SHA>
      <PATCHEDFILES>
        <FILE>cmd/podman/early_init_darwin.go</FILE>
        <FILE>cmd/podman/early_init_linux.go</FILE>
        <FILE>test/e2e/exec_test.go</FILE>
        <FILE>test/e2e/run_test.go</FILE>
        <FILE>test/e2e/toolbox_test.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
