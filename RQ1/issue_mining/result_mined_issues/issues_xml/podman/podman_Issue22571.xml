<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>22571</ISSUENO>
  <ISSUEURL>https://github.com/containers/podman/issues/22571</ISSUEURL>
  <TITLE>Volume mounting ownership inconsistent between Docker &amp; Podman</TITLE>
  <DESCRIPTION>### Issue Description Volume ownership within Podman is different to Docker, and has unexpected behaviors that are detrimental to designing container images that will work on both platforms. The issue is explained with a test rig at https://github.com/BarDweller/mountperms ### Steps to reproduce the issue The issue is explained with a test rig at https://github.com/BarDweller/mountperms ### Describe the results you received Mounted volume ownership can ignore ownership of mountpoint directories in the container image, and does not behave consistently with Docker when mounting volumes to non-existing mountpoints. ### Describe the results you expected Mounted volume ownership should be predictable, and ideally match Dockers. ### podman info output ```yaml $ podman info host: arch: amd64 buildahVersion: 1.32.0 cgroupControllers: - cpu - io - memory - pids cgroupManager: systemd cgroupVersion: v2 conmon: package: conmon-2.1.10-1.fc39.x86_64 path: /usr/bin/conmon version: 'conmon version 2.1.10, commit: ' cpuUtilization: idlePercent: 97.46 systemPercent: 0.57 userPercent: 1.97 cpus: 2 databaseBackend: boltdb distribution: distribution: fedora variant: workstation version: &quot;39&quot; eventLogger: journald freeLocks: 2031 hostname: PODMANVM idMappings: gidmap: - container_id: 0 host_id: 1000 size: 1 - container_id: 1 host_id: 524288 size: 65536 uidmap: - container_id: 0 host_id: 1000 size: 1 - container_id: 1 host_id: 524288 size: 65536 kernel: 6.7.5-200.fc39.x86_64 linkmode: dynamic logDriver: journald memFree: 4063780864 memTotal: 10923556864 networkBackend: netavark networkBackendInfo: backend: netavark dns: package: aardvark-dns-1.10.0-1.fc39.x86_64 path: /usr/libexec/podman/aardvark-dns version: aardvark-dns 1.10.0 package: netavark-1.10.3-1.fc39.x86_64 path: /usr/libexec/podman/netavark version: netavark 1.10.3 ociRuntime: name: crun package: crun-1.14.3-1.fc39.x86_64 path: /usr/bin/crun version: |- crun version 1.14.3 commit: 1961d211ba98f532ea52d2e80f4c20359f241a98 rundir: /run/user/1000/crun spec: 1.0.0 +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +LIBKRUN +WASM:wasmedge +YAJL os: linux pasta: executable: /usr/bin/pasta package: passt-0^20240220.g1e6f92b-1.fc39.x86_64 version: | pasta 0^20240220.g1e6f92b-1.fc39.x86_64-pasta Copyright Red Hat GNU General Public License, version 2 or later &lt;https://www.gnu.org/licenses/old-licenses/gpl-2.0.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. remoteSocket: exists: true path: /run/user/1000/podman/podman.sock security: apparmorEnabled: false capabilities: CAP_CHOWN,CAP_DAC_OVERRIDE,CAP_FOWNER,CAP_FSETID,CAP_KILL,CAP_NET_BIND_SERVICE,CAP_SETFCAP,CAP_SETGID,CAP_SETPCAP,CAP_SETUID,CAP_SYS_CHROOT rootless: true seccompEnabled: true seccompProfilePath: /usr/share/containers/seccomp.json selinuxEnabled: true serviceIsRemote: false slirp4netns: executable: /usr/bin/slirp4netns package: slirp4netns-1.2.2-1.fc39.x86_64 version: |- slirp4netns version 1.2.2 commit: 0ee2d87523e906518d34a6b423271e4826f71faf libslirp: 4.7.0 SLIRP_CONFIG_VERSION_MAX: 4 libseccomp: 2.5.3 swapFree: 1941434368 swapTotal: 1989144576 uptime: 578h 8m 19.00s (Approximately 24.08 days) plugins: authorization: null log: - k8s-file - none - passthrough - journald network: - bridge - macvlan - ipvlan volume: - local registries: 127.0.0.1:5000: Blocked: false Insecure: true Location: 127.0.0.1:5000 MirrorByDigestOnly: false Mirrors: null Prefix: 127.0.0.1:5000 PullFromMirror: &quot;&quot; search: - registry.fedoraproject.org - registry.access.redhat.com - docker.io - quay.io store: configFile: /home/ajo1/.config/containers/storage.conf containerStore: number: 2 paused: 0 running: 1 stopped: 1 graphDriverName: overlay graphOptions: {} graphRoot: /home/ajo1/.local/share/containers/storage graphRootAllocated: 19769851904 graphRootUsed: 19056824320 graphStatus: Backing Filesystem: btrfs Native Overlay Diff: &quot;true&quot; Supports d_type: &quot;true&quot; Supports shifting: &quot;false&quot; Supports volatile: &quot;true&quot; Using metacopy: &quot;false&quot; imageCopyTmpDir: /var/tmp imageStore: number: 25 runRoot: /run/user/1000/containers transientStore: false volumePath: /home/ajo1/.local/share/containers/storage/volumes version: APIVersion: 4.7.0 Built: 1695838680 BuiltTime: Wed Sep 27 14:18:00 2023 GitCommit: &quot;&quot; GoVersion: go1.21.1 Os: linux OsArch: linux/amd64 Version: 4.7.0 ``` ### Podman in a container No ### Privileged Or Rootless Rootless ### Upstream Latest Release Yes ### Additional environment details Additional environment details ### Additional information Additional information like issue happens only occasionally or issue happens with a particular architecture or on a particular setting</DESCRIPTION>
  <REPONAME>podman</REPONAME>
  <TIMEDIFFERENCEDAYS>21</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>Merge pull request #22754 from containers/renovate/github.com-containernetworking-plugins-1.x fix(deps): update module github.com/containernetworking/plugins to v1.5.0</MESSAGE>
    <SHA>f7bd15d5277c0dc9d450c1badffc1ed6f19ecba9</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>Only stop chowning volumes once they're not empty When an empty volume is mounted into a container, Docker will chown that volume appropriately for use in the container. Podman does this as well, but there are differences in the details. In Podman, a chown is presently a one-and-done deal; in Docker, it will continue so long as the volume remains empty. Mount into a dozen containers, but never add content, the chown occurs every time. The chown is also linked to copy-up; it will always occur when a copy-up occurred, despite the volume now not being empty. This PR changes our logic to (mostly) match Docker's. For some reason, the chowning also stops if the volume is chowned to root at any point. This feels like a Docker bug, but as they say, bug for bug compatible. In retrospect, using bools for NeedsChown and NeedsCopyUp was a mistake. Docker isn't actually tracking this stuff; they're just doing a copy-up and permissions change unconditionally as long as the volume is empty. They also have the two linked as one operation, seemingly, despite happening at very different times during container init. Replicating that in our stateful system is nontrivial, hence the need for the new CopiedUp field. Basically, we never want to chown a volume with contents in it, except if that data is a result of a copy-up that resulted from mounting into the current container. Tracking who did the copy-up is the easiest way to do this. Fixes #22571 Signed-off-by: Matthew Heon &lt;matthew.heon@pm.me&gt;</MESSAGE>
      <SHA>046c0e5fc2b32894b1756b1d00f104095472bec8</SHA>
      <PATCHEDFILES>
        <FILE>docs/source/markdown/podman-volume-inspect.1.md</FILE>
        <FILE>libpod/container_internal.go</FILE>
        <FILE>libpod/container_internal_common.go</FILE>
        <FILE>libpod/volume.go</FILE>
        <FILE>libpod/volume_internal.go</FILE>
        <FILE>test/e2e/run_volume_test.go</FILE>
        <FILE>test/system/160-volumes.bats</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Only stop chowning volumes once they're not empty When an empty volume is mounted into a container, Docker will chown that volume appropriately for use in the container. Podman does this as well, but there are differences in the details. In Podman, a chown is presently a one-and-done deal; in Docker, it will continue so long as the volume remains empty. Mount into a dozen containers, but never add content, the chown occurs every time. The chown is also linked to copy-up; it will always occur when a copy-up occurred, despite the volume now not being empty. This PR changes our logic to (mostly) match Docker's. For some reason, the chowning also stops if the volume is chowned to root at any point. This feels like a Docker bug, but as they say, bug for bug compatible. In retrospect, using bools for NeedsChown and NeedsCopyUp was a mistake. Docker isn't actually tracking this stuff; they're just doing a copy-up and permissions change unconditionally as long as the volume is empty. They also have the two linked as one operation, seemingly, despite happening at very different times during container init. Replicating that in our stateful system is nontrivial, hence the need for the new CopiedUp field. Basically, we never want to chown a volume with contents in it, except if that data is a result of a copy-up that resulted from mounting into the current container. Tracking who did the copy-up is the easiest way to do this. Fixes #22571 Signed-off-by: Matthew Heon &lt;matthew.heon@pm.me&gt;</MESSAGE>
      <SHA>6ad6132987f7392e1c1e3f4f4c691f71107830a2</SHA>
      <PATCHEDFILES>
        <FILE>docs/source/markdown/podman-volume-inspect.1.md</FILE>
        <FILE>libpod/container_internal.go</FILE>
        <FILE>libpod/container_internal_common.go</FILE>
        <FILE>libpod/volume.go</FILE>
        <FILE>libpod/volume_internal.go</FILE>
        <FILE>test/e2e/run_volume_test.go</FILE>
        <FILE>test/system/160-volumes.bats</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
