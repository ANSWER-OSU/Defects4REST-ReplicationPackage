<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>2</ISSUENO>
  <ISSUEURL>https://github.com/HTTP-APIs/hydrus/issues/2</ISSUEURL>
  <TITLE>General Starting Introduction To The Project</TITLE>
  <DESCRIPTION>As the first students expressed interest in the project, I write here some more insights about the things at this very early stage. ​The​ objective for this project is to create a demo Web API ​implementing the [HYDRA draft](http://www.hydra-cg.com/spec/latest/core/), that is a​n RDF-based​ framework. The entities defined in the specs are meant to describe the structure and usage of a generic Web API, to let an HYDRA-enabled (&quot;intelligent&quot; or &quot;smart&quot;) client to connect to the API's entrypoint and automatically find out where and how to find the needed data. In this scenario the layers involved are: A. HYDRA **server** that can serve data and metadata to a client (this layer can be split into a traditional lower level server relying on a graph database plus a &quot;HYDRA middleware&quot;), B. **client** that can &quot;understand&quot; HYDRA metadata and connect to HYDRA-enabled services, and possibly &quot;learn and remember&quot; about past interactions with other services to store its own set of concepts to be used in the usage's domain. The objective is generally to let different HYDRA-enabled clients to exchange data each other. These clients can be running on any kind of machine, but the focus for this automation are IoT (connected) devices (industrial or consumer or research). Usage scenario: * the IoT client X needs to know at which TIME the OPERATION Y was performed by the DEVICE Z. Its starting knowledge it is only about the API entrypoint's URI. * the client X fetches the metadata from the entrypoint, it finds out that to get TIME FOR Y ON Z it needs to request the endpoint http://entrypoint/gettime with method GET and passing Y, Z as parameters * the client makes the request to pull the data Different concepts and classes are involved. An RDF domain has to be defined for the metadata exchange to work. To make the demo interesting I suggested we should leverage space exploration and astronomy, so the graph can be based on these vocabularies: ​https://github.com/chronos-pramantha/RDFvocab/blob/master/ld%2Bjson/Spacecraft.json I can suggest possible operations to be requested to the API. Resources are well connected to popular repositories, so we can reach a great amount of knowledge without storing too much. A very good starting design for the server is https://github.com/antoniogarrote/levanzo ​A Python implementation for the &lt;s&gt;server&lt;/s&gt; client: https://github.com/pchampin/hydra-py​ Please enlist questions and comments below. Some resources: * a [blog post](http://blog.theamazingrando.com/in-band-vs-out-of-band.html) about documenting an Web API and programming a client PS. the stack to be used has to be decided yet. We should tend to use a full-Python implementation, except for the lower layer where a graph database is required, we are free to experiment so we can suggest anything in the beginning. At first impression I would avoid Triple Stores and try to use a Graph Database or try to prototype something with Apache TinkerPop or also Spark GraphX, to gain in flexibility to switch to different solutions. At first I would prefer to not get concerned into stability and scalability but just try to reach the first working tool, to let the things to be iterated. UPDATE: To have a better insight, one of the proposed design is described at #3 UPDATE: There are different possible designs that I am proposing. I would like to discuss with you all students and mentors which one is the most interesting and viable: 1. (Astronomy-based) the one you have written about is an idea coming form the quite recent development brought by planetary science about exoplanets. If you have a list of star systems with some planets observed, you can have your REST API to create the observed star and the observed planets orbiting that star. This implementation uses the Astronomy vocabulary. 2. (Engineering-based) the one described in #3 is instead the first idea I had and it is about designing simulated spacecraft spare parts (Cubesat's COTS) and serve these parts using a REST API. In this case the user could create his/her own parts and put them together (with physical constraints applied) to build its own spacecraft. This implementation uses the Spacecraft and SubSystems vocabulary. 3. (NLP based) an idea about a semantic engine that can translate human questions about the Solar System into query for the no.1 above and reply consistently; i.e. &quot;How bigger is Jupiter compared to Earth?&quot; from the user, and the server/client able to reply &quot;Earth has a mass of 5.97 × 10^24 kg. Jupiter has a mass of 1.8986×10^27 kg&quot;. UPDATE: Gitter chat available [here](https://gitter.im/HTTP-APIs/Lobby?utm_source=share-link&amp;utm_medium=link&amp;utm_campaign=share-link) UPDATE: Check also this [architectural proposal](https://github.com/RubenVerborgh/Hydra-Architecture-Diagram)</DESCRIPTION>
  <REPONAME>hydrus</REPONAME>
  <TIMEDIFFERENCEDAYS>380</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>Initial CLI commit on shared fork</MESSAGE>
    <SHA>95250dd16603a59cc8f3f6c81645ea377be83b2c</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>Merge pull request #2 from chirag-jn/patch-1 Update setup.py</MESSAGE>
      <SHA>7662da8efe1e52df79923b95fe7b17a949ac4685</SHA>
      <PATCHEDFILES>
        <FILE>setup.py</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Merge pull request #2 from HTTP-APIs/master Sync with upstream</MESSAGE>
      <SHA>1c2ea167df8146da8d9ae18928b84cbacde0a9b6</SHA>
      <PATCHEDFILES>
        <FILE>README.md</FILE>
        <FILE>cli.py</FILE>
        <FILE>hydrus/app.py</FILE>
        <FILE>hydrus/data/crud.py</FILE>
        <FILE>hydrus/data/db_models.py</FILE>
        <FILE>hydrus/data/exceptions.py</FILE>
        <FILE>hydrus/parser/openapi_parser.py</FILE>
        <FILE>hydrus/samples/hydra_doc_sample.py</FILE>
        <FILE>hydrus/tests/test_crud.py</FILE>
        <FILE>hydrus/tests/test_parser.py</FILE>
        <FILE>petstore_openapi.yaml</FILE>
        <FILE>sqlalchemy_example.db</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
