<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>117644</ISSUENO>
  <ISSUEURL>https://github.com/elastic/elasticsearch/issues/117644</ISSUEURL>
  <TITLE>Investigate synthetic source doc values error</TITLE>
  <DESCRIPTION>As part of running an es|ql error the following error occurred: ``` Caused by: java.io.EOFException: read past EOF: MemorySegmentIndexInput(path=&quot;.../elasticsearch-9.0.0-SNAPSHOT/data/indices/5KLVwOQ3QNOfGg4zLqBt4w/0/index/_11.cfs&quot;) [slice=_11_ES87TSDB_0.dvd] [slice=docs] at org.apache.lucene.store.MemorySegmentIndexInput.readByte(MemorySegmentIndexInput.java:158) ~[lucene-core-10.0.0.jar:?] at org.apache.lucene.store.DataInput.readInt(DataInput.java:97) ~[lucene-core-10.0.0.jar:?] at org.apache.lucene.store.MemorySegmentIndexInput.readInt(MemorySegmentIndexInput.java:273) ~[lucene-core-10.0.0.jar:?] at org.apache.lucene.store.DataInput.readLong(DataInput.java:145) ~[lucene-core-10.0.0.jar:?] at org.apache.lucene.store.MemorySegmentIndexInput.readLong(MemorySegmentIndexInput.java:300) ~[lucene-core-10.0.0.jar:?] at org.apache.lucene.codecs.lucene90.IndexedDISI$Method$2.advanceExactWithinBlock(IndexedDISI.java:692) ~[lucene-core-10.0.0.jar:?] at org.apache.lucene.codecs.lucene90.IndexedDISI.advanceExact(IndexedDISI.java:504) ~[lucene-core-10.0.0.jar:?] at org.elasticsearch.index.codec.tsdb.ES87TSDBDocValuesProducer$9.advanceExact(ES87TSDBDocValuesProducer.java:1052) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.index.codec.tsdb.ES87TSDBDocValuesProducer$5.advanceExact(ES87TSDBDocValuesProducer.java:299) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.apache.lucene.index.SingletonSortedSetDocValues.advanceExact(SingletonSortedSetDocValues.java:83) ~[lucene-core-10.0.0.jar:?] at org.elasticsearch.index.mapper.SortedSetDocValuesSyntheticFieldLoaderLayer$ImmediateDocValuesLoader.advanceToDoc(SortedSetDocValuesSyntheticFieldLoaderLayer.java:116) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.index.mapper.CompositeSyntheticFieldLoader.lambda$docValuesLoader$1(CompositeSyntheticFieldLoader.java:79) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.index.mapper.ObjectMapper$SyntheticSourceFieldLoader$ObjectDocValuesLoader.advanceToDoc(ObjectMapper.java:939) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.index.mapper.ObjectMapper$SyntheticSourceFieldLoader$ObjectDocValuesLoader.advanceToDoc(ObjectMapper.java:939) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.index.mapper.ObjectMapper$SyntheticSourceFieldLoader$ObjectDocValuesLoader.advanceToDoc(ObjectMapper.java:939) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.index.mapper.SourceLoader$Synthetic$SyntheticLeaf.write(SourceLoader.java:210) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.index.mapper.SourceLoader$Synthetic$SyntheticLeaf.source(SourceLoader.java:181) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.index.mapper.SourceLoader$Synthetic$LeafWithMetrics.source(SourceLoader.java:146) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.search.lookup.SyntheticSourceProvider$SyntheticSourceLeafLoader.getSource(SyntheticSourceProvider.java:58) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.search.lookup.SyntheticSourceProvider.getSource(SyntheticSourceProvider.java:42) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.search.lookup.LeafSearchLookup.lambda$new$0(LeafSearchLookup.java:40) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] ... 19 more ``` The es|ql part of the stack trace: ``` [2024-11-14T03:02:47,764][WARN ][o.e.x.e.a.EsqlResponseListener] [elasticsearch-1] Request failed with status [INTERNAL_SERVER_ERROR]: org.elasticsearch.common.io.stream.NotSerializableExceptionWrapper: unchecked_i_o_exception: Couldn't load source at org.elasticsearch.search.lookup.LeafSearchLookup.lambda$new$0(LeafSearchLookup.java:42) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.script.AbstractFieldScript.extractFromSource(AbstractFieldScript.java:107) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.script.AbstractFieldScript.emitFromSource(AbstractFieldScript.java:127) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.script.LongFieldScript$1$1.execute(LongFieldScript.java:29) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.script.AbstractFieldScript.runForDoc(AbstractFieldScript.java:159) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.index.mapper.LongScriptBlockDocValuesReader.read(LongScriptBlockDocValuesReader.java:69) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.index.mapper.LongScriptBlockDocValuesReader.read(LongScriptBlockDocValuesReader.java:56) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.compute.lucene.ValuesSourceReaderOperator.loadFromSingleLeaf(ValuesSourceReaderOperator.java:230) ~[?:?] at org.elasticsearch.compute.lucene.ValuesSourceReaderOperator.process(ValuesSourceReaderOperator.java:143) ~[?:?] at org.elasticsearch.compute.operator.AbstractPageMappingOperator.getOutput(AbstractPageMappingOperator.java:76) ~[?:?] at org.elasticsearch.compute.operator.Driver.runSingleLoopIteration(Driver.java:258) ~[?:?] at org.elasticsearch.compute.operator.Driver.run(Driver.java:189) ~[?:?] at org.elasticsearch.compute.operator.Driver$1.doRun(Driver.java:378) ~[?:?] at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:27) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.common.util.concurrent.TimedRunnable.doRun(TimedRunnable.java:34) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.common.util.concurrent.ThreadContext$ContextPreservingAbstractRunnable.doRun(ThreadContext.java:1023) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:27) ~[elasticsearch-9.0.0-SNAPSHOT.jar:?] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144) ~[?:?] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642) ~[?:?] at java.lang.Thread.run(Thread.java:1570) ~[?:?] ``` [full-stacktrace.txt](https://github.com/user-attachments/files/17957949/stacktrace.txt) Queries like this fail ``` POST /_query { &quot;query&quot;: &quot;FROM .ds-logs-nginx.error-default-2024.11.13-000001 | EVAL compression = rally.doc_size::DOUBLE / rally.message_size | STATS AVG(compression)&quot; } ```</DESCRIPTION>
  <REPONAME>elasticsearch</REPONAME>
  <TIMEDIFFERENCEDAYS>7</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>ESQL: Mute CATEGORIZE optimizer tests on release builds (#117690)</MESSAGE>
    <SHA>64dfed4e1f0610014f01fc7285fccac831a62c74</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>Avoid reusing source providers for script based block loaders. This change attempts to solve the following issue: ValueSourceOperator can read values in row striding or columnar fashion. When values are read in columnar fashion and multiple runtime fields synthetize source then this can cause the same `SourceProvider` evaluation the same range of docs ids multiple times. This can then result in unexpected io errors at the codec level. This is because the same doc value instances are used by `SourceProvider`. Re-evaluating the same docids is in violation of the contract of the DocIdSetIterator#advance(...) / DocIdSetIterator#advanceExact(...) methods, which documents that unexpected behaviour can occur if target docid is lower than current docid position. Note that this is only an issue for synthetic source loader and not for stored source loader. And not when executing in row stride fashion which sometimes happen in compute engine and always happen in _search api. Closes #117644</MESSAGE>
      <SHA>619c4411a7fc2f8f36d2d0dbccaaeb6a2363a716</SHA>
      <PATCHEDFILES>
        <FILE>server/src/main/java/org/elasticsearch/index/query/SearchExecutionContext.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/EsPhysicalOperationProviders.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Address mapping and compute engine runtime field issues (#117792) This change addresses the following issues: Fields mapped as runtime fields not getting stored if source mode is synthetic. Address java.io.EOFException when an es|ql query uses multiple runtime fields that fallback to source when source mode is synthetic. (1) Address concurrency issue when runtime fields get pushed down to Lucene. (2) 1: ValueSourceOperator can read values in row striding or columnar fashion. When values are read in columnar fashion and multiple runtime fields synthetize source then this can cause the same SourceProvider evaluation the same range of docs ids multiple times. This can then result in unexpected io errors at the codec level. This is because the same doc value instances are used by SourceProvider. Re-evaluating the same docids is in violation of the contract of the DocIdSetIterator#advance(...) / DocIdSetIterator#advanceExact(...) methods, which documents that unexpected behaviour can occur if target docid is lower than current docid position. Note that this is only an issue for synthetic source loader and not for stored source loader. And not when executing in row stride fashion which sometimes happen in compute engine and always happen in _search api. 2: The concurrency issue that arrises with source provider if source operator executes in parallel with data portioning set to DOC. The same SourceProvider instance then gets access by multiple threads concurrently. SourceProviders implementations are not designed to handle concurrent access. Closes #117644</MESSAGE>
      <SHA>56ef3154ca7f2f334d584d62edb6ee15c83e7d19</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/117792.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/index/query/SearchExecutionContext.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java</FILE>
        <FILE>x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/action/EsqlActionIT.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/EsPhysicalOperationProviders.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ComputeService.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ReinitializingSourceProvider.java</FILE>
        <FILE>x-pack/plugin/logsdb/src/javaRestTest/java/org/elasticsearch/xpack/logsdb/LogsdbRestIT.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Address mapping and compute engine runtime field issues (#117792) This change addresses the following issues: Fields mapped as runtime fields not getting stored if source mode is synthetic. Address java.io.EOFException when an es|ql query uses multiple runtime fields that fallback to source when source mode is synthetic. (1) Address concurrency issue when runtime fields get pushed down to Lucene. (2) 1: ValueSourceOperator can read values in row striding or columnar fashion. When values are read in columnar fashion and multiple runtime fields synthetize source then this can cause the same SourceProvider evaluation the same range of docs ids multiple times. This can then result in unexpected io errors at the codec level. This is because the same doc value instances are used by SourceProvider. Re-evaluating the same docids is in violation of the contract of the DocIdSetIterator#advance(...) / DocIdSetIterator#advanceExact(...) methods, which documents that unexpected behaviour can occur if target docid is lower than current docid position. Note that this is only an issue for synthetic source loader and not for stored source loader. And not when executing in row stride fashion which sometimes happen in compute engine and always happen in _search api. 2: The concurrency issue that arrises with source provider if source operator executes in parallel with data portioning set to DOC. The same SourceProvider instance then gets access by multiple threads concurrently. SourceProviders implementations are not designed to handle concurrent access. Closes #117644</MESSAGE>
      <SHA>2051401d5049aaa6308838920230514698321b38</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/117792.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/index/query/SearchExecutionContext.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java</FILE>
        <FILE>x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/action/EsqlActionIT.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/EsPhysicalOperationProviders.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ComputeService.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ReinitializingSourceProvider.java</FILE>
        <FILE>x-pack/plugin/logsdb/src/javaRestTest/java/org/elasticsearch/xpack/logsdb/LogsdbRestIT.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Address mapping and compute engine runtime field issues (#117792) This change addresses the following issues: Fields mapped as runtime fields not getting stored if source mode is synthetic. Address java.io.EOFException when an es|ql query uses multiple runtime fields that fallback to source when source mode is synthetic. (1) Address concurrency issue when runtime fields get pushed down to Lucene. (2) 1: ValueSourceOperator can read values in row striding or columnar fashion. When values are read in columnar fashion and multiple runtime fields synthetize source then this can cause the same SourceProvider evaluation the same range of docs ids multiple times. This can then result in unexpected io errors at the codec level. This is because the same doc value instances are used by SourceProvider. Re-evaluating the same docids is in violation of the contract of the DocIdSetIterator#advance(...) / DocIdSetIterator#advanceExact(...) methods, which documents that unexpected behaviour can occur if target docid is lower than current docid position. Note that this is only an issue for synthetic source loader and not for stored source loader. And not when executing in row stride fashion which sometimes happen in compute engine and always happen in _search api. 2: The concurrency issue that arrises with source provider if source operator executes in parallel with data portioning set to DOC. The same SourceProvider instance then gets access by multiple threads concurrently. SourceProviders implementations are not designed to handle concurrent access. Closes #117644</MESSAGE>
      <SHA>4ff643b87002d1505f276a14d0e9c1bd2853da05</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/117792.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/index/query/SearchExecutionContext.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java</FILE>
        <FILE>x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/action/EsqlActionIT.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/EsPhysicalOperationProviders.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ComputeService.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ReinitializingSourceProvider.java</FILE>
        <FILE>x-pack/plugin/logsdb/src/javaRestTest/java/org/elasticsearch/xpack/logsdb/LogsdbRestIT.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>[8.17] Address mapping and compute engine runtime field issues (#117792) (#118048) * Address mapping and compute engine runtime field issues (#117792) This change addresses the following issues: Fields mapped as runtime fields not getting stored if source mode is synthetic. Address java.io.EOFException when an es|ql query uses multiple runtime fields that fallback to source when source mode is synthetic. (1) Address concurrency issue when runtime fields get pushed down to Lucene. (2) 1: ValueSourceOperator can read values in row striding or columnar fashion. When values are read in columnar fashion and multiple runtime fields synthetize source then this can cause the same SourceProvider evaluation the same range of docs ids multiple times. This can then result in unexpected io errors at the codec level. This is because the same doc value instances are used by SourceProvider. Re-evaluating the same docids is in violation of the contract of the DocIdSetIterator#advance(...) / DocIdSetIterator#advanceExact(...) methods, which documents that unexpected behaviour can occur if target docid is lower than current docid position. Note that this is only an issue for synthetic source loader and not for stored source loader. And not when executing in row stride fashion which sometimes happen in compute engine and always happen in _search api. 2: The concurrency issue that arrises with source provider if source operator executes in parallel with data portioning set to DOC. The same SourceProvider instance then gets access by multiple threads concurrently. SourceProviders implementations are not designed to handle concurrent access. Closes #117644 * fixed compile error after backporting</MESSAGE>
      <SHA>7cb1cbe0f64005e18cbe40218057d64fbe65e7f7</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/117792.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/index/query/SearchExecutionContext.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java</FILE>
        <FILE>x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/action/EsqlActionIT.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/EsPhysicalOperationProviders.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ComputeService.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ReinitializingSourceProvider.java</FILE>
        <FILE>x-pack/plugin/logsdb/src/javaRestTest/java/org/elasticsearch/xpack/logsdb/LogsdbRestIT.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>[8.x] Address mapping and compute engine runtime field issues (#117792) (#118049) * Address mapping and compute engine runtime field issues (#117792) This change addresses the following issues: Fields mapped as runtime fields not getting stored if source mode is synthetic. Address java.io.EOFException when an es|ql query uses multiple runtime fields that fallback to source when source mode is synthetic. (1) Address concurrency issue when runtime fields get pushed down to Lucene. (2) 1: ValueSourceOperator can read values in row striding or columnar fashion. When values are read in columnar fashion and multiple runtime fields synthetize source then this can cause the same SourceProvider evaluation the same range of docs ids multiple times. This can then result in unexpected io errors at the codec level. This is because the same doc value instances are used by SourceProvider. Re-evaluating the same docids is in violation of the contract of the DocIdSetIterator#advance(...) / DocIdSetIterator#advanceExact(...) methods, which documents that unexpected behaviour can occur if target docid is lower than current docid position. Note that this is only an issue for synthetic source loader and not for stored source loader. And not when executing in row stride fashion which sometimes happen in compute engine and always happen in _search api. 2: The concurrency issue that arrises with source provider if source operator executes in parallel with data portioning set to DOC. The same SourceProvider instance then gets access by multiple threads concurrently. SourceProviders implementations are not designed to handle concurrent access. Closes #117644</MESSAGE>
      <SHA>b8afe64eb637535691a66d0696296e90202b2350</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/117792.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/index/query/SearchExecutionContext.java</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java</FILE>
        <FILE>x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/action/EsqlActionIT.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/EsPhysicalOperationProviders.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ComputeService.java</FILE>
        <FILE>x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ReinitializingSourceProvider.java</FILE>
        <FILE>x-pack/plugin/logsdb/src/javaRestTest/java/org/elasticsearch/xpack/logsdb/LogsdbRestIT.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
