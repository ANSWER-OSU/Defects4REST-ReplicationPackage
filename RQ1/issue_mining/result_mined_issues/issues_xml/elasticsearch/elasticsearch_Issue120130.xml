<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>120130</ISSUENO>
  <ISSUEURL>https://github.com/elastic/elasticsearch/issues/120130</ISSUEURL>
  <TITLE>Performance regression in MatchedQueriesPhase</TITLE>
  <DESCRIPTION>### Elasticsearch Version 8.17.0 ### Installed Plugins _No response_ ### Java Version _bundled_ ### OS Version Public docker image ### Problem Description We started noticing some search tasks hanging around for several hours after we upgraded from 8.6.1 to 8.15.1. They were marked as cancelled but wouldn't get cleaned up for a long time. When inspecting the queries, we noticed they were very heavy geospatial queries, with hundreds to thousands of polygon queries on a `geo_point` field. We assumed this was just complex queries, but couldn't really explain why the cancelled tasks hung around for so long. We recently upgraded to 8.17.0 and still continued to see this behavior, and started noticing more and more of this happening. We finally started digging in more and checked the hot threads on the nodes these tasks were running and saw this part of a stack trace every time this was happening: ``` ... app/org.apache.lucene.core@9.12.0/org.apache.lucene.index.SingletonSortedNumericDocValues.nextValue(SingletonSortedNumericDocValues.java:72) app/org.apache.lucene.core@9.12.0/org.apache.lucene.document.LatLonDocValuesQuery$2.matches(LatLonDocValuesQuery.java:178) app/org.apache.lucene.core@9.12.0/org.apache.lucene.search.TwoPhaseIterator$TwoPhaseIteratorAsDocIdSetIterator.doNext(TwoPhaseIterator.java:85) app/org.apache.lucene.core@9.12.0/org.apache.lucene.search.TwoPhaseIterator$TwoPhaseIteratorAsDocIdSetIterator.advance(TwoPhaseIterator.java:78) app/org.elasticsearch.server@8.17.0/org.elasticsearch.search.fetch.subphase.MatchedQueriesPhase$1.process(MatchedQueriesPhase.java:79) app/org.elasticsearch.server@8.17.0/org.elasticsearch.search.FetchPhase$1.nextDoc(FetchPhase.java:182) ... ``` This led us to do some testing and confirmed that the issue is fully around the fact that we are doing named queries on each of these polygons so we can find out which polygon the point was in. When removing the named queries, this issue goes away. Looking at changes to the `MatchedQueriesPhase`, I believe this may be caused by https://github.com/elastic/elasticsearch/pull/94564. Before this MR, matches were found using `Bits matchingBits = Lucene.asSequentialAccessBits(readerContext.reader().maxDoc(), ss);`, which under the hood [operates roughly like](https://github.com/elastic/elasticsearch/blob/30948acd593641611385f55128705bb081ca217f/server/src/main/java/org/elasticsearch/common/lucene/Lucene.java#L800): ```java final Scorer scorer = scorerSupplier.get(estimatedGetCount); // this never returns null final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator(); final DocIdSetIterator iterator; if (twoPhase == null) { iterator = scorer.iterator(); } else { iterator = twoPhase.approximation(); } return new Bits() { ... @Override public boolean get(int index) { ... int doc = iterator.docID(); if (doc &lt; index) { try { doc = iterator.advance(index); } catch (IOException e) { throw new IllegalStateException(&quot;Cannot advance iterator&quot;, e); } } if (index == doc) { try { return previousMatched = twoPhase == null || twoPhase.matches(); } catch (IOException e) { throw new IllegalStateException(&quot;Cannot validate match&quot;, e); } } ``` Here, `advance` is always run on the inner iterator in the case of the `twoPhaseIterator`, never on the `twoPhaseIterator` itself. The [new code](https://github.com/elastic/elasticsearch/blob/7ddcfeb638fad5d8d4d77d8097d4ca264ca79dea/server/src/main/java/org/elasticsearch/search/fetch/subphase/MatchedQueriesPhase.java#L59) simply does: ```java @Override public void setNextReader(LeafReaderContext readerContext) throws IOException { matchingIterators.clear(); for (Map.Entry&lt;String, Weight&gt; entry : weights.entrySet()) { ScorerSupplier ss = entry.getValue().scorerSupplier(readerContext); if (ss != null) { Scorer scorer = ss.get(0L); if (scorer != null) { matchingIterators.put(entry.getKey(), scorer); } } } } @Override public void process(HitContext hitContext) throws IOException { Map&lt;String, Float&gt; matches = new LinkedHashMap&lt;&gt;(); int doc = hitContext.docId(); for (Map.Entry&lt;String, Scorer&gt; entry : matchingIterators.entrySet()) { Scorer scorer = entry.getValue(); if (scorer.iterator().docID() &lt; doc) { scorer.iterator().advance(doc); } if (scorer.iterator().docID() == doc) { matches.put(entry.getKey(), scorer.score()); } } hitContext.hit().matchedQueries(matches); } ``` in this case, `ScorerSupplier ss` is a `IndexOrDocValuesQuery`, which is wrapping an `index` query, `LatLonPointQuery`, and a `docValues` query, `LatLonDocValuesQuery`. When the scorer returned by the scorer supplier ends up being the doc values query instead of the index query due to the cost, `scorer.iterator` is a `TwoPhaseIteratorAsDocIdSetIterator`. Looking at that [implementation](https://github.com/apache/lucene/blob/5851f44952095e77c84c7f0d5941777cfcaad34c/lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java#L56): ```java @Override public int advance(int target) throws IOException { return doNext(approximation.advance(target)); } private int doNext(int doc) throws IOException { for (; ; doc = approximation.nextDoc()) { if (doc == NO_MORE_DOCS) { return NO_MORE_DOCS; } else if (twoPhaseIterator.matches()) { return doc; } } } ``` Which looks like after advancing `approximation` (which in this case is `LatLonDocValuesQuery`) to `target`, it iterates over every record in `approximation` until it finds the next match, meaning the polygon query will run on every record in the shard (or segment?) even if it's not part of the results being fetched. The original implementation didn't have this issue because it effectively was doing `twoPhaseIterator.approximation.advance(target)` directly instead. ### Steps to Reproduce Very hard to reproduce, we had to do hundreds of small polygons that matched very few records to finally recreate it on our production data. I can modify the `MatchedQueriesIT` tests to show that the `TwoPhaseIterator` is used when the estimated [cost of the index query is greater than 8](https://github.com/apache/lucene/blob/5851f44952095e77c84c7f0d5941777cfcaad34c/lucene/core/src/java/org/apache/lucene/search/IndexOrDocValuesQuery.java#L174), which means it estimates at least 8 points match the query on the shard (or segment?). ### Logs (if relevant) _No response_</DESCRIPTION>
  <REPONAME>elasticsearch</REPONAME>
  <TIMEDIFFERENCEDAYS>0</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>Introduce new handshake version for v9 (#120109) This commit introduces `V9_HANDSHAKE_VERSION` which is the transport version that will eventually be for handshakes sent by v9 nodes. It does not adjust the handshake version yet, because we must first backport this to the v8.18 branch so that v8.18 nodes can understand the new v9 handshakes.</MESSAGE>
    <SHA>825b5dead429c7ae9fe14e8fb45d731ecbc5cdf3</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>Use approximation to advance matched queries This PR resolves a regression introduced in #94564 by ensuring that the approximation is used when advancing matched query clauses. Utilizing the two-phase iterator to validate matches guarantees that we do not attempt to find the next document fulfilling the two-phase criteria beyond the current document. This fix prevents scenarios where matching a document in the second phase significantly increases query complexity, especially in cases involving restrictive second-pass filters. Closes #120130</MESSAGE>
      <SHA>dbc500912d1e7212037b8c2ac6e128d11c5ee767</SHA>
      <PATCHEDFILES>
        <FILE>server/src/main/java/org/elasticsearch/search/fetch/subphase/MatchedQueriesPhase.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Use approximation to advance matched queries (#120133) This PR resolves a regression introduced in #94564 by ensuring that the approximation is used when advancing matched query clauses. Utilizing the two-phase iterator to validate matches guarantees that we do not attempt to find the next document fulfilling the two-phase criteria beyond the current document. This fix prevents scenarios where matching a document in the second phase significantly increases query complexity, especially in cases involving restrictive second-pass filters. Closes #120130</MESSAGE>
      <SHA>1b08d4b337d1af6d548b810fa5d8ebdef07223de</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/120133.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/fetch/subphase/MatchedQueriesPhase.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Use approximation to advance matched queries (#120133) This PR resolves a regression introduced in #94564 by ensuring that the approximation is used when advancing matched query clauses. Utilizing the two-phase iterator to validate matches guarantees that we do not attempt to find the next document fulfilling the two-phase criteria beyond the current document. This fix prevents scenarios where matching a document in the second phase significantly increases query complexity, especially in cases involving restrictive second-pass filters. Closes #120130</MESSAGE>
      <SHA>a124b77fe9b34222a181a47c3e2e4602539efb8f</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/120133.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/fetch/subphase/MatchedQueriesPhase.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Use approximation to advance matched queries (#120133) This PR resolves a regression introduced in #94564 by ensuring that the approximation is used when advancing matched query clauses. Utilizing the two-phase iterator to validate matches guarantees that we do not attempt to find the next document fulfilling the two-phase criteria beyond the current document. This fix prevents scenarios where matching a document in the second phase significantly increases query complexity, especially in cases involving restrictive second-pass filters. Closes #120130</MESSAGE>
      <SHA>eb70e72d8bfeef117f35cbbecbd896b7941712c6</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/120133.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/fetch/subphase/MatchedQueriesPhase.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Use approximation to advance matched queries (#120133) This PR resolves a regression introduced in #94564 by ensuring that the approximation is used when advancing matched query clauses. Utilizing the two-phase iterator to validate matches guarantees that we do not attempt to find the next document fulfilling the two-phase criteria beyond the current document. This fix prevents scenarios where matching a document in the second phase significantly increases query complexity, especially in cases involving restrictive second-pass filters. Closes #120130</MESSAGE>
      <SHA>77392c31a85febbd41170c9d904a402f8aab6d23</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/120133.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/fetch/subphase/MatchedQueriesPhase.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Use approximation to advance matched queries (#120133) (#120145) This PR resolves a regression introduced in #94564 by ensuring that the approximation is used when advancing matched query clauses. Utilizing the two-phase iterator to validate matches guarantees that we do not attempt to find the next document fulfilling the two-phase criteria beyond the current document. This fix prevents scenarios where matching a document in the second phase significantly increases query complexity, especially in cases involving restrictive second-pass filters. Closes #120130</MESSAGE>
      <SHA>9103d6e67d4581e3e1e5e9a275f2c0a6127afd64</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/120133.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/fetch/subphase/MatchedQueriesPhase.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>Use approximation to advance matched queries (#120133) (#120146) This PR resolves a regression introduced in #94564 by ensuring that the approximation is used when advancing matched query clauses. Utilizing the two-phase iterator to validate matches guarantees that we do not attempt to find the next document fulfilling the two-phase criteria beyond the current document. This fix prevents scenarios where matching a document in the second phase significantly increases query complexity, especially in cases involving restrictive second-pass filters. Closes #120130</MESSAGE>
      <SHA>85f8a64177fe95d80b99b9b8c8060bdd666c351a</SHA>
      <PATCHEDFILES>
        <FILE>docs/changelog/120133.yaml</FILE>
        <FILE>server/src/main/java/org/elasticsearch/search/fetch/subphase/MatchedQueriesPhase.java</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
