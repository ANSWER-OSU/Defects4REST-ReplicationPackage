<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>17021</ISSUENO>
  <ISSUEURL>https://github.com/OrchardCMS/OrchardCore/issues/17021</ISSUEURL>
  <TITLE>Replace Nest package with Elastic.Clients.Elasticsearch</TITLE>
  <DESCRIPTION>Nest package is deprecated are was replaced with Elastic.Clients.Elasticsearch few years back. Once that is done, we can change the way we deserialize the custom analyzers and custom token-filters. The code will look more like this ``` using System.Collections.Concurrent; using System.Text.Json; using System.Text.Json.Nodes; using Elasticsearch.Net; using Microsoft.Extensions.Logging; using Microsoft.Extensions.Options; using Nest; using OrchardCore.ContentManagement; using OrchardCore.Contents.Indexing; using OrchardCore.Environment.Shell; using OrchardCore.Indexing; using OrchardCore.Modules; using OrchardCore.Search.Elasticsearch.Core.Mappings; using OrchardCore.Search.Elasticsearch.Core.Models; namespace OrchardCore.Search.Elasticsearch.Core.Services; /// &lt;summary&gt; /// Provides methods to manage Elasticsearch indices. /// &lt;/summary&gt; public sealed class ElasticIndexManager { private const string _separator = &quot;_&quot;; private readonly IElasticClient _elasticClient; private readonly ShellSettings _shellSettings; private readonly IClock _clock; private readonly ILogger _logger; private readonly ElasticsearchOptions _elasticSearchOptions; private readonly ConcurrentDictionary&lt;string, DateTime&gt; _timestamps = new(StringComparer.OrdinalIgnoreCase); private const string _lastTaskId = &quot;last_task_id&quot;; private static readonly Dictionary&lt;string, Type&gt; _analyzerGetter = new(StringComparer.OrdinalIgnoreCase) { { ElasticsearchConstants.DefaultAnalyzer, typeof(StandardAnalyzer) }, { ElasticsearchConstants.SimpleAnalyzer, typeof(SimpleAnalyzer) }, { ElasticsearchConstants.KeywordAnalyzer, typeof(KeywordAnalyzer) }, { ElasticsearchConstants.WhitespaceAnalyzer, typeof(WhitespaceAnalyzer) }, { ElasticsearchConstants.PatternAnalyzer, typeof(PatternAnalyzer) }, { ElasticsearchConstants.LanguageAnalyzer, typeof(LanguageAnalyzer) }, { ElasticsearchConstants.FingerprintAnalyzer, typeof(FingerprintAnalyzer) }, { ElasticsearchConstants.CustomAnalyzer, typeof(CustomAnalyzer) }, { ElasticsearchConstants.StopAnalyzer, typeof(StopAnalyzer) }, }; private static readonly Dictionary&lt;string, Type&gt; _tokenFilterGetter = new(StringComparer.OrdinalIgnoreCase) { { &quot;asciifolding&quot;, typeof(AsciiFoldingTokenFilter) }, { &quot;common_grams&quot;, typeof(CommonGramsTokenFilter) }, { &quot;condition&quot;, typeof(ConditionTokenFilter) }, { &quot;delimited_payload&quot;, typeof(DelimitedPayloadTokenFilter) }, { &quot;dictionary_decompounder&quot;, typeof(DictionaryDecompounderTokenFilter) }, { &quot;edge_ngram&quot;, typeof(EdgeNGramTokenFilter) }, { &quot;elision&quot;, typeof(ElisionTokenFilter) }, { &quot;fingerprint&quot;, typeof(FingerprintTokenFilter) }, { &quot;hunspell&quot;, typeof(HunspellTokenFilter) }, { &quot;hyphenation_decompounder&quot;, typeof(HyphenationDecompounderTokenFilter) }, { &quot;icu_collation&quot;, typeof(IcuCollationTokenFilter) }, { &quot;icu_folding&quot;, typeof(IcuFoldingTokenFilter) }, { &quot;icu_normalizer&quot;, typeof(IcuNormalizationTokenFilter) }, { &quot;icu_transform&quot;, typeof(IcuTransformTokenFilter) }, { &quot;keep_types&quot;, typeof(KeepTypesTokenFilter) }, { &quot;keep&quot;, typeof(KeepWordsTokenFilter) }, { &quot;keyword_marker&quot;, typeof(KeywordMarkerTokenFilter) }, { &quot;kstem&quot;, typeof(KStemTokenFilter) }, { &quot;kuromoji_part_of_speech&quot;, typeof(KuromojiPartOfSpeechTokenFilter) }, { &quot;kuromoji_readingform&quot;, typeof(KuromojiReadingFormTokenFilter) }, { &quot;kuromoji_stemmer&quot;, typeof(KuromojiStemmerTokenFilter) }, { &quot;length&quot;, typeof(LengthTokenFilter) }, { &quot;limit&quot;, typeof(LimitTokenCountTokenFilter) }, { &quot;lowercase&quot;, typeof(LowercaseTokenFilter) }, { &quot;multiplexer&quot;, typeof(MultiplexerTokenFilter) }, { &quot;ngram&quot;, typeof(NGramTokenFilter) }, { &quot;nori_part_of_speech&quot;, typeof(NoriPartOfSpeechTokenFilter) }, { &quot;pattern_capture&quot;, typeof(PatternCaptureTokenFilter) }, { &quot;pattern_replace&quot;, typeof(PatternReplaceTokenFilter) }, { &quot;phonetic&quot;, typeof(PhoneticTokenFilter) }, { &quot;porter_stem&quot;, typeof(PorterStemTokenFilter) }, { &quot;remove_duplicates&quot;, typeof(RemoveDuplicatesTokenFilter) }, { &quot;reverse&quot;, typeof(ReverseTokenFilter) }, { &quot;shingle&quot;, typeof(ShingleTokenFilter) }, { &quot;snowball&quot;, typeof(SnowballTokenFilter) }, { &quot;stemmer_override&quot;, typeof(StemmerOverrideTokenFilter) }, { &quot;stemmer&quot;, typeof(StemmerTokenFilter) }, { &quot;stop&quot;, typeof(StopTokenFilter) }, { &quot;synonym_graph&quot;, typeof(SynonymGraphTokenFilter) }, { &quot;synonym&quot;, typeof(SynonymTokenFilter) }, { &quot;trim&quot;, typeof(TrimTokenFilter) }, { &quot;truncate&quot;, typeof(TruncateTokenFilter) }, { &quot;unique&quot;, typeof(UniqueTokenFilter) }, { &quot;uppercase&quot;, typeof(UppercaseTokenFilter) }, { &quot;word_delimiter_graph&quot;, typeof(WordDelimiterGraphTokenFilter) }, { &quot;word_delimiter&quot;, typeof(WordDelimiterTokenFilter) } }; private static readonly List&lt;char&gt; _charsToRemove = [ '\\', '/', '*', '\&quot;', '|', '&lt;', '&gt;', '`', '\'', ' ', '#', ':', '.', ]; private string _indexPrefix; public ElasticIndexManager( IElasticClient elasticClient, ShellSettings shellSettings, IOptions&lt;ElasticsearchOptions&gt; elasticsearchOptions, IClock clock, ILogger&lt;ElasticIndexManager&gt; logger ) { _elasticClient = elasticClient; _shellSettings = shellSettings; _clock = clock; _logger = logger; _elasticSearchOptions = elasticsearchOptions.Value; } /// &lt;summary&gt; /// &lt;para&gt;Creates an Elasticsearch index with _source mapping.&lt;/para&gt; /// &lt;para&gt;&lt;see href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/8.3/mapping-source-field.html#disable-source-field&quot;/&gt;.&lt;/para&gt; /// &lt;para&gt;Specify an analyzer for an index based on the ElasticsearchIndexSettings. /// &lt;see href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/specify-analyzer.html#specify-index-time-default-analyzer&quot;/&gt;, /// &lt;see href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/master/analysis-analyzers.html&quot;/&gt;. /// &lt;/para&gt; /// &lt;/summary&gt; /// &lt;returns&gt;&lt;see cref=&quot;bool&quot;/&gt;.&lt;/returns&gt; public async Task&lt;bool&gt; CreateIndexAsync(ElasticIndexSettings elasticIndexSettings) { // Get Index name scoped by ShellName if (await ExistsAsync(elasticIndexSettings.IndexName)) { return true; } var analysisDescriptor = new AnalysisDescriptor(); var indexSettingsDescriptor = new IndexSettingsDescriptor(); // The name &quot;standardanalyzer&quot; is a legacy used prior OC 1.6 release. It can be removed in future releases. var analyzerName = (elasticIndexSettings.AnalyzerName == &quot;standardanalyzer&quot; ? null : elasticIndexSettings.AnalyzerName) ?? ElasticsearchConstants.DefaultAnalyzer; if (_elasticSearchOptions.Analyzers is not null &amp;&amp; _elasticSearchOptions.Analyzers.TryGetValue(analyzerName, out var analyzerProperties)) { var analyzer = GetAnalyzer(analyzerProperties); analysisDescriptor.Analyzers(a =&gt; a.UserDefined(analyzerName, analyzer)); } if (_elasticSearchOptions.TokenFilters is not null &amp;&amp; _elasticSearchOptions.TokenFilters.Count &gt; 0) { var tokenFiltersDescriptor = GetTokenFiltersDescriptor(_elasticSearchOptions.TokenFilters); analysisDescriptor.TokenFilters(d =&gt; tokenFiltersDescriptor); } indexSettingsDescriptor.Analysis(a =&gt; analysisDescriptor); // Custom metadata to store the last indexing task id. var IndexingState = new FluentDictionary&lt;string, object&gt;() { { _lastTaskId, 0 }, }; var fullIndexName = GetFullIndexName(elasticIndexSettings.IndexName); var createIndexDescriptor = new CreateIndexDescriptor(fullIndexName) .Settings(s =&gt; indexSettingsDescriptor) .Map(m =&gt; m .SourceField(s =&gt; s .Enabled(elasticIndexSettings.StoreSourceData) .Excludes([IndexingConstants.DisplayTextAnalyzedKey])) .Meta(me =&gt; IndexingState)); var response = await _elasticClient.Indices.CreateAsync(createIndexDescriptor); // We force some mappings for common fields. await _elasticClient.MapAsync&lt;string&gt;(p =&gt; p .Index(fullIndexName) .Properties(p =&gt; p .Keyword(obj =&gt; obj .Name(IndexingConstants.ContentItemIdKey) ) .Keyword(obj =&gt; obj .Name(IndexingConstants.ContentItemVersionIdKey) ) .Keyword(obj =&gt; obj .Name(IndexingConstants.OwnerKey) ) .Text(obj =&gt; obj .Name(IndexingConstants.FullTextKey) ) )); // ContainedPart mappings. await _elasticClient.MapAsync&lt;ContainedPartModel&gt;(p =&gt; p .Index(fullIndexName) .Properties(p =&gt; p .Object&lt;ContainedPartModel&gt;(obj =&gt; obj .Name(IndexingConstants.ContainedPartKey) .AutoMap() ) )); // We map DisplayText here because we have 3 different fields with it. // We can't have Content.ContentItem.DisplayText as it is mapped as an Object in Elasticsearch. await _elasticClient.MapAsync&lt;DisplayTextModel&gt;(p =&gt; p .Index(fullIndexName) .Properties(p =&gt; p .Object&lt;DisplayTextModel&gt;(obj =&gt; obj .Name(IndexingConstants.DisplayTextKey) .AutoMap() ) )); // We map ContentType as a keyword because else the automatic mapping will break the queries. // We need to access it with Content.ContentItem.ContentType as a keyword // for the ContentPickerResultProvider(s). await _elasticClient.MapAsync&lt;string&gt;(p =&gt; p .Index(fullIndexName) .Properties(p =&gt; p .Keyword(obj =&gt; obj .Name(IndexingConstants.ContentTypeKey) ) )); // DynamicTemplates mapping for Taxonomy indexing mostly. await _elasticClient.MapAsync&lt;string&gt;(p =&gt; p .Index(fullIndexName) .DynamicTemplates(d =&gt; d .DynamicTemplate(&quot;*.Inherited&quot;, dyn =&gt; dyn .MatchMappingType(&quot;string&quot;) .PathMatch(&quot;*&quot; + IndexingConstants.InheritedKey) .Mapping(m =&gt; m .Keyword(k =&gt; k)) ) .DynamicTemplate(&quot;*.Ids&quot;, dyn =&gt; dyn .MatchMappingType(&quot;string&quot;) .PathMatch(&quot;*&quot; + IndexingConstants.IdsKey) .Mapping(m =&gt; m .Keyword(k =&gt; k)) ) ) ); // DynamicTemplates mapping for Geo fields, the GeoPointFieldIndexHandler adds a Location index by default. await _elasticClient.MapAsync&lt;object&gt;(p =&gt; p .Index(fullIndexName) .DynamicTemplates(d =&gt; d .DynamicTemplate(&quot;*.Location&quot;, dyn =&gt; dyn .MatchMappingType(&quot;object&quot;) .PathMatch(&quot;*&quot; + &quot;.Location&quot;) .Mapping(m =&gt; m.GeoPoint(g =&gt; g)) ) ) ); return response.Acknowledged; } private static TokenFiltersDescriptor GetTokenFiltersDescriptor(Dictionary&lt;string, JsonObject&gt; filters) { var descriptor = new TokenFiltersDescriptor(); foreach (var filter in filters) { if (!filter.Value.TryGetPropertyValue(&quot;type&quot;, out var typeObject) || !_tokenFilterGetter.TryGetValue(typeObject.ToString(), out var tokenFilterType)) { continue; } RemoveTypeNode(filter.Value); var tokenFilter = filter.Value.ToObject(tokenFilterType) as ITokenFilter; if (tokenFilter is not null) { descriptor.UserDefined(filter.Key, tokenFilter); } } return descriptor; } private static IAnalyzer GetAnalyzer(JsonObject analyzerProperties) { IAnalyzer analyzer = null; if (analyzerProperties.TryGetPropertyValue(&quot;type&quot;, out var typeObject) &amp;&amp; _analyzerGetter.TryGetValue(typeObject.ToString(), out var analyzerType)) { RemoveTypeNode(analyzerProperties); analyzer = analyzerProperties.ToObject(analyzerType) as IAnalyzer; } if (analyzer == null) { if (_analyzerGetter.TryGetValue(ElasticsearchConstants.DefaultAnalyzer, out analyzerType)) { RemoveTypeNode(analyzerProperties); analyzer = analyzerProperties.ToObject(analyzerType) as IAnalyzer; } else { RemoveTypeNode(analyzerProperties); analyzer = analyzerProperties.ToObject(_analyzerGetter.First().Value) as IAnalyzer; } } return analyzer; } private static void RemoveTypeNode(JsonObject analyzerProperties) { var typeKey = analyzerProperties.FirstOrDefault(x =&gt; x.Key.Equals(&quot;type&quot;, StringComparison.OrdinalIgnoreCase)).Key; if (typeKey is not null) { analyzerProperties.Remove(typeKey); } } public async Task&lt;string&gt; GetIndexMappings(string indexName) { var response = await _elasticClient.LowLevel.Indices.GetMappingAsync&lt;StringResponse&gt;(GetFullIndexName(indexName)); if (!response.Success) { _logger.LogWarning(&quot;There were issues retrieving index mappings from Elasticsearch. {OriginalException}&quot;, response.OriginalException); } return response.Body; } public async Task&lt;string&gt; GetIndexSettings(string indexName) { var response = await _elasticClient.LowLevel.Indices.GetSettingsAsync&lt;StringResponse&gt;(GetFullIndexName(indexName)); if (!response.Success) { _logger.LogWarning(&quot;There were issues retrieving index settings from Elasticsearch. {OriginalException}&quot;, response.OriginalException); } return response.Body; } public async Task&lt;string&gt; GetIndexInfo(string indexName) { var response = await _elasticClient.LowLevel.Indices.GetAsync&lt;StringResponse&gt;(GetFullIndexName(indexName)); if (!response.Success) { _logger.LogWarning(&quot;There were issues retrieving index info from Elasticsearch. {OriginalException}&quot;, response.OriginalException); } return response.Body; } /// &lt;summary&gt; /// Store a last_task_id in the Elasticsearch index _meta mappings. /// This allows storing the last indexing task id executed on the Elasticsearch index. /// &lt;see href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-meta-field.html&quot;/&gt;. /// &lt;/summary&gt; public async Task SetLastTaskId(string indexName, long lastTaskId) { var IndexingState = new FluentDictionary&lt;string, object&gt;() { { _lastTaskId, lastTaskId }, }; var putMappingRequest = new PutMappingRequest(GetFullIndexName(indexName)) { Meta = IndexingState }; await _elasticClient.Indices.PutMappingAsync(putMappingRequest); } /// &lt;summary&gt; /// Get a last_task_id in the Elasticsearch index _meta mappings. /// This allows retrieving the last indexing task id executed on the index. /// &lt;/summary&gt; public async Task&lt;long&gt; GetLastTaskId(string indexName) { var jsonDocument = JsonDocument.Parse(await GetIndexMappings(indexName)); jsonDocument.RootElement.TryGetProperty(GetFullIndexName(indexName), out var jsonElement); jsonElement.TryGetProperty(&quot;mappings&quot;, out var mappings); mappings.TryGetProperty(&quot;_meta&quot;, out var meta); meta.TryGetProperty(_lastTaskId, out var lastTaskId); lastTaskId.TryGetInt64(out var longValue); return longValue; } public async Task&lt;bool&gt; DeleteDocumentsAsync(string indexName, IEnumerable&lt;string&gt; contentItemIds) { var success = true; if (contentItemIds.Any()) { var descriptor = new BulkDescriptor(); foreach (var id in contentItemIds) { descriptor.Delete&lt;Dictionary&lt;string, object&gt;&gt;(d =&gt; d .Index(GetFullIndexName(indexName)) .Id(id) ); } var response = await _elasticClient.BulkAsync(descriptor); if (response.Errors) { _logger.LogWarning(&quot;There were issues deleting documents from Elasticsearch. {OriginalException}&quot;, response.OriginalException); } success = response.IsValid; } return success; } /// &lt;summary&gt; /// Deletes all documents in an index in one request. /// &lt;see href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete-by-query.html&quot;/&gt;. /// &lt;/summary&gt; public async Task&lt;bool&gt; DeleteAllDocumentsAsync(string indexName) { var response = await _elasticClient.DeleteByQueryAsync&lt;Dictionary&lt;string, object&gt;&gt;(del =&gt; del .Index(GetFullIndexName(indexName)) .Query(q =&gt; q.MatchAll()) ); return response.IsValid; } public async Task&lt;bool&gt; DeleteIndex(string indexName) { if (await ExistsAsync(indexName)) { var result = await _elasticClient.Indices.DeleteAsync(GetFullIndexName(indexName)); return result.Acknowledged; } return true; } /// &lt;summary&gt; /// Verify if an index exists for the current tenant. /// &lt;/summary&gt; public async Task&lt;bool&gt; ExistsAsync(string indexName) { if (string.IsNullOrWhiteSpace(indexName)) { return false; } var existResponse = await _elasticClient.Indices.ExistsAsync(GetFullIndexName(indexName)); return existResponse.Exists; } /// &lt;summary&gt; /// Makes sure that the index names are compliant with Elasticsearch specifications. /// &lt;see href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html#indices-create-api-path-params&quot;/&gt;. /// &lt;/summary&gt; public static string ToSafeIndexName(string indexName) { indexName = indexName.ToLowerInvariant(); if (indexName[0] == '-' || indexName[0] == '_' || indexName[0] == '+' || indexName[0] == '.') { indexName = indexName.Remove(0, 1); } _charsToRemove.ForEach(c =&gt; indexName = indexName.Replace(c.ToString(), string.Empty)); return indexName; } public async Task StoreDocumentsAsync(string indexName, IEnumerable&lt;DocumentIndex&gt; indexDocuments) { var documents = new List&lt;Dictionary&lt;string, object&gt;&gt;(); foreach (var indexDocument in indexDocuments) { documents.Add(CreateElasticDocument(indexDocument)); } if (documents.Count &gt; 0) { var descriptor = new BulkDescriptor(); foreach (var document in documents) { descriptor.Index&lt;Dictionary&lt;string, object&gt;&gt;(op =&gt; op .Id(document.GetValueOrDefault(&quot;ContentItemId&quot;).ToString()) .Document(document) .Index(GetFullIndexName(indexName)) ); } var result = await _elasticClient.BulkAsync(d =&gt; descriptor); if (result.Errors) { _logger.LogWarning(&quot;There were issues reported indexing the documents. {ServerError}&quot;, result.ServerError); } } } /// &lt;summary&gt; /// Returns results from a search made with a NEST QueryContainer query. /// &lt;/summary&gt; /// &lt;param name=&quot;indexName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;query&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;sort&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;from&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;size&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;see cref=&quot;ElasticTopDocs&quot;/&gt;.&lt;/returns&gt; public async Task&lt;ElasticTopDocs&gt; SearchAsync(string indexName, QueryContainer query, List&lt;ISort&gt; sort, int from, int size) { ArgumentException.ThrowIfNullOrEmpty(indexName); ArgumentNullException.ThrowIfNull(query); var elasticTopDocs = new ElasticTopDocs() { TopDocs = [], }; if (await ExistsAsync(indexName)) { var fullIndexName = GetFullIndexName(indexName); var searchRequest = new SearchRequest(fullIndexName) { Query = query, From = from, Size = size, Sort = sort ?? [], }; var searchResponse = await _elasticClient.SearchAsync&lt;Dictionary&lt;string, object&gt;&gt;(searchRequest); if (searchResponse.IsValid) { elasticTopDocs.Count = searchResponse.Hits.Count; var documents = searchResponse.Documents.GetEnumerator(); var hits = searchResponse.Hits.GetEnumerator(); while (documents.MoveNext() &amp;&amp; hits.MoveNext()) { var document = documents.Current; if (document != null) { elasticTopDocs.TopDocs.Add(document); continue; } var hit = hits.Current; var topDoc = new Dictionary&lt;string, object&gt; { { nameof(ContentItem.ContentItemId), hit.Id }, }; elasticTopDocs.TopDocs.Add(topDoc); } } _timestamps[fullIndexName] = _clock.UtcNow; } return elasticTopDocs; } /// &lt;summary&gt; /// Returns results from a search made with NEST Fluent DSL query. /// &lt;/summary&gt; public async Task SearchAsync(string indexName, Func&lt;IElasticClient, Task&gt; elasticClient) { ArgumentException.ThrowIfNullOrEmpty(indexName); if (await ExistsAsync(indexName)) { await elasticClient(_elasticClient); _timestamps[GetFullIndexName(indexName)] = _clock.UtcNow; } } private static Dictionary&lt;string, object&gt; CreateElasticDocument(DocumentIndex documentIndex) { var entries = new Dictionary&lt;string, object&gt; { { IndexingConstants.ContentItemIdKey, documentIndex.ContentItemId }, { IndexingConstants.ContentItemVersionIdKey, documentIndex.ContentItemVersionId } }; foreach (var entry in documentIndex.Entries) { switch (entry.Type) { case DocumentIndexBase.Types.Boolean: if (entry.Value is bool boolValue) { AddValue(entries, entry.Name, boolValue); } break; case DocumentIndexBase.Types.DateTime: if (entry.Value is DateTimeOffset offsetValue) { AddValue(entries, entry.Name, offsetValue); } else if (entry.Value is DateTime dateTimeValue) { AddValue(entries, entry.Name, dateTimeValue.ToUniversalTime()); } break; case DocumentIndexBase.Types.Integer: if (entry.Value != null &amp;&amp; long.TryParse(entry.Value.ToString(), out var value)) { AddValue(entries, entry.Name, value); } break; case DocumentIndexBase.Types.Number: if (entry.Value != null) { AddValue(entries, entry.Name, Convert.ToDouble(entry.Value)); } break; case DocumentIndexBase.Types.Text: if (entry.Value != null) { var stringValue = Convert.ToString(entry.Value); if (!string.IsNullOrEmpty(stringValue)) { AddValue(entries, entry.Name, stringValue); } } break; case DocumentIndexBase.Types.GeoPoint: if (entry.Value is DocumentIndexBase.GeoPoint point) { AddValue(entries, entry.Name, new GeoLocation((double)point.Latitude, (double)point.Longitude)); } break; } } return entries; } public string GetFullIndexName(string indexName) { ArgumentException.ThrowIfNullOrEmpty(indexName); return GetIndexPrefix() + _separator + indexName; } private static void AddValue(Dictionary&lt;string, object&gt; entries, string key, object value) { if (entries.TryAdd(key, value)) { return; } // At this point, we know that a value already exists. if (entries[key] is List&lt;object&gt; list) { list.Add(value); entries[key] = list; return; } // Convert the existing value to a list of values. var values = new List&lt;object&gt;() { entries[key], value, }; entries[key] = values; } private string GetIndexPrefix() { if (_indexPrefix == null) { var parts = new List&lt;string&gt;(); if (!string.IsNullOrWhiteSpace(_elasticSearchOptions.IndexPrefix)) { parts.Add(_elasticSearchOptions.IndexPrefix.ToLowerInvariant()); } parts.Add(_shellSettings.Name.ToLowerInvariant()); _indexPrefix = string.Join(_separator, parts); } return _indexPrefix; } } ```</DESCRIPTION>
  <REPONAME>OrchardCore</REPONAME>
  <TIMEDIFFERENCEDAYS>12</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>Correctly create custom analyzer in Elasticsearch (#17013)</MESSAGE>
    <SHA>05bd65ab262bbee90b63bb23b6f021b7a8c9d820</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>Replace Nest package with Elastic.Clients.Elasticsearch Fix #17021</MESSAGE>
      <SHA>80ed98430c34d04740bcffb7b6084d81809d3a13</SHA>
      <PATCHEDFILES>
        <FILE>Directory.Packages.props</FILE>
        <FILE>src/OrchardCore.Modules/OrchardCore.Search.Elasticsearch/Drivers/ElasticSettingsDisplayDriver.cs</FILE>
        <FILE>src/OrchardCore.Modules/OrchardCore.Search.Elasticsearch/OrchardCore.Search.Elasticsearch.csproj</FILE>
        <FILE>src/OrchardCore.Modules/OrchardCore.Search.Elasticsearch/Services/ElasticSearchService.cs</FILE>
        <FILE>src/OrchardCore.Modules/OrchardCore.Search.Elasticsearch/Startup.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Abstractions/IElasticAnalyzer.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Abstractions/IElasticsearchQueryService.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Abstractions/OrchardCore.Search.Elasticsearch.Abstractions.csproj</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/Mappings/ContainedPartModel.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/Mappings/DisplayTextModel.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/Models/ElasticConnectionOptions.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/OrchardCore.Search.Elasticsearch.Core.csproj</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/Providers/ElasticContentPickerResultProvider.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/ServiceCollectionExtensions.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/Services/ElasticAnalyzer.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/Services/ElasticConnectionOptionsConfigurations.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/Services/ElasticIndexManager.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/Services/ElasticQueryService.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/Services/ElasticSearchClientFactory.cs</FILE>
        <FILE>src/OrchardCore/OrchardCore.Search.Elasticsearch.Core/Services/ElasticSearchQueryService.cs</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
