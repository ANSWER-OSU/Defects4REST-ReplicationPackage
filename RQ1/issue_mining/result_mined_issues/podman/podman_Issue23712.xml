<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>23712</ISSUENO>
  <ISSUEURL>https://github.com/containers/podman/issues/23712</ISSUEURL>
  <TITLE>Compat API endpoints for events and container logs with `follow=true` do not send response immediately like Docker</TITLE>
  <DESCRIPTION>### Issue Description It seems that the Podman compat API does not immediately return an HTTP response when querying `/events` or `/containers/${id}/logs?follow=true&amp;stdout=true&amp;stderr=true` if no events or logs are produced yet. In this case, the client cannot determine whether the request was successful until some data is received. For example, I use [Vector](https://github.com/vectordotdev/vector), which in turn uses the [Bollard](https://github.com/fussybeaver/bollard) library to interact with the Docker API, to collect logs from Docker and Podman. When Vector starts fetching system events and container logs using the Podman 5.2.1 compat API via the socket `unix:///run/podman/podman.sock`, the requests fail with error `RequestTimeoutError` after a 2 minute timeout if no response is received from Podman, causing Vector to stop monitoring the container. At the same time, everything works fine with Docker. Vector logs: ``` vector[19350]: 2024-08-21T17:05:19.072757Z INFO source{component_kind=&quot;source&quot; component_id=src_podman component_type=docker_logs}: vector::sources::docker_logs: Capturing logs from now on. now=2024-08-21T17:05:19.072742638+00:00 vector[19350]: 2024-08-21T17:05:19.072925Z INFO source{component_kind=&quot;source&quot; component_id=src_podman component_type=docker_logs}: vector::sources::docker_logs: Listening to docker log events. vector[19350]: 2024-08-21T17:05:19.114233Z INFO source{component_kind=&quot;source&quot; component_id=src_podman component_type=docker_logs}: vector::internal_events::docker_logs: Started watching for container logs. container_id=6c7b2459bcb71617e192003e88955527b738bb20dc4b6b5cbbc798112b45b357 vector[19350]: 2024-08-21T17:07:19.098385Z ERROR source{component_kind=&quot;source&quot; component_id=src_podman component_type=docker_logs}: vector::internal_events::docker_logs: Error in communication with Docker daemon. error=RequestTimeoutError error_type=&quot;connection_failed&quot; stage=&quot;receiving&quot; container_id=None internal_log_rate_limit=true vector[19350]: 2024-08-21T17:07:19.115508Z ERROR source{component_kind=&quot;source&quot; component_id=src_podman component_type=docker_logs}: vector::internal_events::docker_logs: Internal log [Error in communication with Docker daemon.] is being suppressed to avoid flooding. vector[19350]: 2024-08-21T17:07:19.115597Z INFO source{component_kind=&quot;source&quot; component_id=src_podman component_type=docker_logs}: vector::internal_events::docker_logs: Stopped watching for container logs. container_id=6c7b2459bcb71617e192003e88955527b738bb20dc4b6b5cbbc798112b45b357 ``` ### Steps to reproduce the issue 1. Run any container that does not produce logs: `id=$(podman run -d --rm alpine sleep infinity)` 2. Get events: `curl -v --unix-socket /run/podman/podman.sock &quot;http://d/events&quot; -o -` 3. Get container logs: `curl -v --unix-socket /run/podman/podman.sock &quot;http://d/containers/${id}/logs?follow=true&amp;stdout=true&amp;stderr=true&quot; -o -` ### Describe the results you received There is no HTTP response if no events or logs are produced: ``` # curl -v --unix-socket /run/podman/podman.sock &quot;http://d/events&quot; -o - * Trying /run/podman/podman.sock:0... * Connected to d (/run/podman/podman.sock) port 80 &gt; GET /events HTTP/1.1 &gt; Host: d &gt; User-Agent: curl/8.6.0 &gt; Accept: */* &gt; ^C # curl -v --unix-socket /run/podman/podman.sock &quot;http://d/containers/${id}/logs?follow=true&amp;stdout=true&amp;stderr=true&quot; -o - * Trying /run/podman/podman.sock:0... * Connected to d (/run/podman/podman.sock) port 80 &gt; GET /containers/6c7b2459bcb71617e192003e88955527b738bb20dc4b6b5cbbc798112b45b357/logs?follow=true&amp;stdout=true&amp;stderr=true HTTP/1.1 &gt; Host: d &gt; User-Agent: curl/8.6.0 &gt; Accept: */* &gt; ^C ``` ### Describe the results you expected ### For events endpoint Receive the HTTP response even if there are no logs or events. Like with Podman 5.0.3: ``` # curl -v --unix-socket /run/podman/podman.sock &quot;http://d/events&quot; -o - * Trying /run/podman/podman.sock:0... * Connected to d (/run/podman/podman.sock) port 80 &gt; GET /events HTTP/1.1 &gt; Host: d &gt; User-Agent: curl/8.6.0 &gt; Accept: */* &gt; &lt; HTTP/1.1 200 OK &lt; Api-Version: 1.41 &lt; Content-Type: application/json &lt; Libpod-Api-Version: 5.0.3 &lt; Server: Libpod/5.0.3 (linux) &lt; X-Reference-Id: 0xc00006a338 &lt; Date: Wed, 21 Aug 2024 19:16:59 GMT &lt; Transfer-Encoding: chunked &lt; ^C ``` Like with Docker: ``` # curl -v --unix-socket /run/docker.sock &quot;http://d/events&quot; -o - * Trying /run/docker.sock:0... * Connected to d (/run/docker.sock) port 80 &gt; GET /events HTTP/1.1 &gt; Host: d &gt; User-Agent: curl/8.6.0 &gt; Accept: */* &gt; &lt; HTTP/1.1 200 OK &lt; Api-Version: 1.46 &lt; Content-Type: application/json &lt; Docker-Experimental: false &lt; Ostype: linux &lt; Server: Docker/27.1.2 (linux) &lt; Date: Wed, 21 Aug 2024 20:08:13 GMT &lt; Transfer-Encoding: chunked &lt; ^C ``` ### For container logs endpoint Recevice the HTTP response even if there are no logs or events. Like with Docker: ``` # curl -v --unix-socket /run/docker.sock &quot;http://d/containers/${id}/logs?follow=true&amp;stdout=true&amp;stderr=true&quot; -o - * Trying /run/docker.sock:0... * Connected to d (/run/docker.sock) port 80 &gt; GET /containers/c60d242591740394e4ef8f2dd9a4264a931dffd9f357d0adb2b1e53dd0024196/logs?follow=true&amp;stdout=true&amp;stderr=true HTTP/1.1 &gt; Host: d &gt; User-Agent: curl/8.6.0 &gt; Accept: */* &gt; &lt; HTTP/1.1 200 OK &lt; Api-Version: 1.46 &lt; Content-Type: application/vnd.docker.multiplexed-stream &lt; Docker-Experimental: false &lt; Ostype: linux &lt; Server: Docker/27.1.2 (linux) &lt; Date: Wed, 21 Aug 2024 20:10:30 GMT &lt; Transfer-Encoding: chunked &lt; ^C ``` ### podman info output ```yaml host: arch: amd64 buildahVersion: 1.37.1 cgroupControllers: - cpuset - cpu - io - memory - hugetlb - pids cgroupManager: cgroupfs cgroupVersion: v2 conmon: package: conmon-2.1.10-1.fc40.x86_64 path: /usr/bin/conmon version: 'conmon version 2.1.10, commit: ' cpuUtilization: idlePercent: 99.44 systemPercent: 0.27 userPercent: 0.29 cpus: 2 databaseBackend: sqlite distribution: distribution: fedora variant: container version: &quot;40&quot; eventLogger: file freeLocks: 2048 hostname: 2659a687fd77 idMappings: gidmap: null uidmap: null kernel: 5.15.0-208.159.3.2.el9uek.x86_64 linkmode: dynamic logDriver: k8s-file memFree: 1310531584 memTotal: 3624329216 networkBackend: netavark networkBackendInfo: backend: netavark dns: package: aardvark-dns-1.12.1-1.fc40.x86_64 path: /usr/libexec/podman/aardvark-dns version: aardvark-dns 1.12.1 package: netavark-1.12.1-1.fc40.x86_64 path: /usr/libexec/podman/netavark version: netavark 1.12.1 ociRuntime: name: crun package: crun-1.15-1.fc40.x86_64 path: /usr/bin/crun version: |- crun version 1.15 commit: e6eacaf4034e84185fd8780ac9262bbf57082278 rundir: /run/crun spec: 1.0.0 +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +LIBKRUN +WASM:wasmedge +YAJL os: linux pasta: executable: /usr/bin/pasta package: passt-0^20240814.g61c0b0d-1.fc40.x86_64 version: | pasta 0^20240814.g61c0b0d-1.fc40.x86_64-pasta Copyright Red Hat GNU General Public License, version 2 or later &lt;https://www.gnu.org/licenses/old-licenses/gpl-2.0.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. remoteSocket: exists: false path: /run/podman/podman.sock rootlessNetworkCmd: pasta security: apparmorEnabled: false capabilities: CAP_CHOWN,CAP_DAC_OVERRIDE,CAP_FOWNER,CAP_FSETID,CAP_KILL,CAP_NET_BIND_SERVICE,CAP_SETFCAP,CAP_SETGID,CAP_SETPCAP,CAP_SETUID,CAP_SYS_CHROOT rootless: false seccompEnabled: true seccompProfilePath: /usr/share/containers/seccomp.json selinuxEnabled: false serviceIsRemote: false slirp4netns: executable: &quot;&quot; package: &quot;&quot; version: &quot;&quot; swapFree: 2147479552 swapTotal: 2147479552 uptime: 27h 22m 32.00s (Approximately 1.12 days) variant: &quot;&quot; plugins: authorization: null log: - k8s-file - none - passthrough - journald network: - bridge - macvlan - ipvlan volume: - local registries: search: - registry.fedoraproject.org - registry.access.redhat.com - docker.io store: configFile: /etc/containers/storage.conf containerStore: number: 0 paused: 0 running: 0 stopped: 0 graphDriverName: overlay graphOptions: overlay.imagestore: /usr/lib/containers/storage overlay.mount_program: Executable: /usr/bin/fuse-overlayfs Package: fuse-overlayfs-1.13-1.fc40.x86_64 Version: |- fusermount3 version: 3.16.2 fuse-overlayfs: version 1.13-dev FUSE library version 3.16.2 using FUSE kernel interface version 7.38 overlay.mountopt: nodev,fsync=0 graphRoot: /var/lib/containers/storage graphRootAllocated: 21027463168 graphRootUsed: 10851258368 graphStatus: Backing Filesystem: extfs Native Overlay Diff: &quot;false&quot; Supports d_type: &quot;true&quot; Supports shifting: &quot;true&quot; Supports volatile: &quot;true&quot; Using metacopy: &quot;false&quot; imageCopyTmpDir: /var/tmp imageStore: number: 0 runRoot: /run/containers/storage transientStore: false volumePath: /var/lib/containers/storage/volumes version: APIVersion: 5.2.1 Built: 1723593600 BuiltTime: Wed Aug 14 00:00:00 2024 GitCommit: &quot;&quot; GoVersion: go1.22.5 Os: linux OsArch: linux/amd64 Version: 5.2.1 ``` ### Podman in a container Yes ### Privileged Or Rootless Privileged ### Upstream Latest Release Yes ### Additional environment details Additional environment details ### Additional information Additional information like issue happens only occasionally or issue happens with a particular architecture or on a particular setting</DESCRIPTION>
  <REPONAME>podman</REPONAME>
  <TIMEDIFFERENCEDAYS>74</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>events: remove memory eventer This type is unsused, undocumented and basically broken. If this would be used anywhere it will just deadlock after writing 100+ events without reading as the channel will just be full. It was added in commit 8da5f3f733 but never used there nor is there any justification why this was added in the commit message or PR comments. Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
    <SHA>e34fb9cde773852cd4cf3d8d22efc70f34a93c43</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>rework event code to improve API errors One of the problems with the Events() API was that you had to call it in a new goroutine. This meant the the error returned by it had to be read back via a second channel. This cuased other bugs in the past but here the biggest problem is that basic errors such as invalid since/until options were not directly returned to the caller. It meant in the API we were not able to write http code 200 quickly because we always waited for the first event or error from the channels. This in turn made some clients not happy as they assume the server hangs on time out if no such events are generated. To fix this we resturcture the entire event flow. First we spawn the goroutine inside the eventer Read() function so not all the callers have to. Then we can return the basic error quickly without the goroutine. The caller then checks the error like any normal function and the API can use this one to decide which status code to return. Second we now return errors/event in one channel then the callers can decide to ignore or log them which makes it a bit more clear. Fixes c46884aa93 (&quot;podman events: check for an error after we finish reading events&quot;) Fixes #23712 Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
      <SHA>fdff4324606716d6910d985ea3e2f34d76dc8824</SHA>
      <PATCHEDFILES>
        <FILE>cmd/podman/system/events.go</FILE>
        <FILE>libpod/events.go</FILE>
        <FILE>libpod/events/config.go</FILE>
        <FILE>libpod/events/journal_linux.go</FILE>
        <FILE>libpod/events/logfile.go</FILE>
        <FILE>pkg/api/handlers/compat/events.go</FILE>
        <FILE>pkg/api/handlers/utils/containers.go</FILE>
        <FILE>pkg/domain/entities/types.go</FILE>
        <FILE>pkg/domain/infra/tunnel/events.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>API: container logs flush status code API clients expect the status code quickly otherwise they can time out. If we do not flush we may not write the header immediately and only when futher logs are send. Fixes #23712 Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
      <SHA>2edd9707e2744c97f8f5b0da6385fa65615bf986</SHA>
      <PATCHEDFILES>
        <FILE>pkg/api/handlers/compat/containers_logs.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>rework event code to improve API errors One of the problems with the Events() API was that you had to call it in a new goroutine. This meant the the error returned by it had to be read back via a second channel. This cuased other bugs in the past but here the biggest problem is that basic errors such as invalid since/until options were not directly returned to the caller. It meant in the API we were not able to write http code 200 quickly because we always waited for the first event or error from the channels. This in turn made some clients not happy as they assume the server hangs on time out if no such events are generated. To fix this we resturcture the entire event flow. First we spawn the goroutine inside the eventer Read() function so not all the callers have to. Then we can return the basic error quickly without the goroutine. The caller then checks the error like any normal function and the API can use this one to decide which status code to return. Second we now return errors/event in one channel then the callers can decide to ignore or log them which makes it a bit more clear. Fixes c46884aa93 (&quot;podman events: check for an error after we finish reading events&quot;) Fixes #23712 Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
      <SHA>658c039d26ea6a78a7a6561239ac0f973fcbf9c4</SHA>
      <PATCHEDFILES>
        <FILE>cmd/podman/system/events.go</FILE>
        <FILE>libpod/events.go</FILE>
        <FILE>libpod/events/config.go</FILE>
        <FILE>libpod/events/journal_linux.go</FILE>
        <FILE>libpod/events/logfile.go</FILE>
        <FILE>pkg/api/handlers/compat/events.go</FILE>
        <FILE>pkg/api/handlers/utils/containers.go</FILE>
        <FILE>pkg/domain/entities/types.go</FILE>
        <FILE>pkg/domain/infra/tunnel/events.go</FILE>
        <FILE>test/apiv2/27-containersEvents.at</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>API: container logs flush status code API clients expect the status code quickly otherwise they can time out. If we do not flush we may not write the header immediately and only when futher logs are send. Fixes #23712 Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
      <SHA>9d130c888da2b83b08d359be11fe414ab1711d4e</SHA>
      <PATCHEDFILES>
        <FILE>pkg/api/handlers/compat/containers_logs.go</FILE>
        <FILE>test/apiv2/20-containers.at</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>rework event code to improve API errors One of the problems with the Events() API was that you had to call it in a new goroutine. This meant the the error returned by it had to be read back via a second channel. This cuased other bugs in the past but here the biggest problem is that basic errors such as invalid since/until options were not directly returned to the caller. It meant in the API we were not able to write http code 200 quickly because we always waited for the first event or error from the channels. This in turn made some clients not happy as they assume the server hangs on time out if no such events are generated. To fix this we resturcture the entire event flow. First we spawn the goroutine inside the eventer Read() function so not all the callers have to. Then we can return the basic error quickly without the goroutine. The caller then checks the error like any normal function and the API can use this one to decide which status code to return. Second we now return errors/event in one channel then the callers can decide to ignore or log them which makes it a bit more clear. Fixes c46884aa93 (&quot;podman events: check for an error after we finish reading events&quot;) Fixes #23712 Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
      <SHA>896e17023d2fe990ec4813f1526bfba85d43a0a4</SHA>
      <PATCHEDFILES>
        <FILE>cmd/podman/system/events.go</FILE>
        <FILE>libpod/events.go</FILE>
        <FILE>libpod/events/config.go</FILE>
        <FILE>libpod/events/journal_linux.go</FILE>
        <FILE>libpod/events/logfile.go</FILE>
        <FILE>pkg/api/handlers/compat/events.go</FILE>
        <FILE>pkg/api/handlers/utils/containers.go</FILE>
        <FILE>pkg/bindings/system/system.go</FILE>
        <FILE>pkg/domain/entities/types.go</FILE>
        <FILE>pkg/domain/infra/tunnel/events.go</FILE>
        <FILE>test/apiv2/27-containersEvents.at</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>API: container logs flush status code API clients expect the status code quickly otherwise they can time out. If we do not flush we may not write the header immediately and only when futher logs are send. Fixes #23712 Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
      <SHA>0420921b571d61845c2cd6e0c88081c1ab31d4a7</SHA>
      <PATCHEDFILES>
        <FILE>pkg/api/handlers/compat/containers_logs.go</FILE>
        <FILE>test/apiv2/20-containers.at</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>rework event code to improve API errors One of the problems with the Events() API was that you had to call it in a new goroutine. This meant the the error returned by it had to be read back via a second channel. This cuased other bugs in the past but here the biggest problem is that basic errors such as invalid since/until options were not directly returned to the caller. It meant in the API we were not able to write http code 200 quickly because we always waited for the first event or error from the channels. This in turn made some clients not happy as they assume the server hangs on time out if no such events are generated. To fix this we resturcture the entire event flow. First we spawn the goroutine inside the eventer Read() function so not all the callers have to. Then we can return the basic error quickly without the goroutine. The caller then checks the error like any normal function and the API can use this one to decide which status code to return. Second we now return errors/event in one channel then the callers can decide to ignore or log them which makes it a bit more clear. Fixes c46884aa93 (&quot;podman events: check for an error after we finish reading events&quot;) Fixes #23712 Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
      <SHA>768ad8653af4cebd069a865a5dbf4a7ec8517444</SHA>
      <PATCHEDFILES>
        <FILE>cmd/podman/system/events.go</FILE>
        <FILE>libpod/events.go</FILE>
        <FILE>libpod/events/config.go</FILE>
        <FILE>libpod/events/journal_linux.go</FILE>
        <FILE>libpod/events/logfile.go</FILE>
        <FILE>pkg/api/handlers/compat/events.go</FILE>
        <FILE>pkg/api/handlers/utils/containers.go</FILE>
        <FILE>pkg/bindings/system/system.go</FILE>
        <FILE>pkg/domain/entities/types.go</FILE>
        <FILE>pkg/domain/infra/tunnel/events.go</FILE>
        <FILE>test/apiv2/27-containersEvents.at</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>API: container logs flush status code API clients expect the status code quickly otherwise they can time out. If we do not flush we may not write the header immediately and only when futher logs are send. Fixes #23712 Signed-off-by: Paul Holzinger &lt;pholzing@redhat.com&gt;</MESSAGE>
      <SHA>e6d987882eec98e0ced1b11858921401abecb705</SHA>
      <PATCHEDFILES>
        <FILE>pkg/api/handlers/compat/containers_logs.go</FILE>
        <FILE>test/apiv2/20-containers.at</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
