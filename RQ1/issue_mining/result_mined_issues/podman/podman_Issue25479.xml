<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>25479</ISSUENO>
  <ISSUEURL>https://github.com/containers/podman/issues/25479</ISSUEURL>
  <TITLE>Race when waiting for &quot;not-running&quot; when auto remove is on</TITLE>
  <DESCRIPTION>### Issue Description This is a result of investigation of https://code.forgejo.org/forgejo/runner/issues/429 and https://code.forgejo.org/forgejo/runner/issues/413 Short version is - certain CI configurations run podman container with `--rm` flag set and then wait for it to exit to get exit code (Sequence of API calls is somewhat - create -&gt; start -&gt; attach -&gt; wait). For some reason it depends on how long the container was running. For short runs (&lt; 5s) it almost always succeeds, but for longer runs (&gt;= 10s) it sometimes fails with status -1 and an empty code. After it was bisected to PR #23646, I took some closer look at `WaitForExit` / `WaitForConditionWithInterval` functions. On successful runs `WaitForExit` returns 0, nil. While it fails, `syncContainer` (https://github.com/containers/podman/blob/01feac8af51f57614033838a225f5b43a7ef178b/libpod/container_api.go#L651) returns &quot;container has already been removed&quot;. Since next line handles &quot;no such container&quot; error already, just changing the condition to `if errors.Is(err, define.ErrNoSuchCtr) || errors.Is(err, define.ErrCtrRemoved)` does the trick - `c.runtime.state.GetContainerExitCode` returns successful return code. I didn't look deep into what causes this race, but it seems reasonable to expect that both `ErrNoSuchCtr` and `ErrCtrRemoved` are handled similarly for this use-case. ### Steps to reproduce the issue Pretty much described https://code.forgejo.org/forgejo/runner/issues/413#issuecomment-28320 However, since this is a race it may not be that easy to reproduce. ### Describe the results you received Waiting for container which started with `--rm` returns `-1`, `nil`, even though container exited with code `0`. ### Describe the results you expected Get actual exit code of the container. ### podman info output ```yaml host: arch: amd64 buildahVersion: 1.39.0 cgroupControllers: - cpuset - cpu - memory - pids cgroupManager: systemd cgroupVersion: v2 conmon: package: conmon-2.1.13-1.1.x86_64 path: /usr/bin/conmon version: 'conmon version 2.1.13, commit: unknown' cpuUtilization: idlePercent: 99.03 systemPercent: 0.16 userPercent: 0.81 cpus: 24 databaseBackend: sqlite distribution: distribution: opensuse-tumbleweed version: &quot;20250303&quot; eventLogger: journald freeLocks: 2040 hostname: ybox idMappings: gidmap: - container_id: 0 host_id: 1000 size: 1 - container_id: 1 host_id: 100000 size: 65536 uidmap: - container_id: 0 host_id: 1000 size: 1 - container_id: 1 host_id: 100000 size: 65536 kernel: 6.13.5-1-default linkmode: dynamic logDriver: journald memFree: 29576376320 memTotal: 64860278784 networkBackend: netavark networkBackendInfo: backend: netavark dns: package: aardvark-dns-1.14.0-1.1.x86_64 path: /usr/libexec/podman/aardvark-dns version: aardvark-dns 1.14.0 package: netavark-1.14.0-1.1.x86_64 path: /usr/libexec/podman/netavark version: netavark 1.14.0 ociRuntime: name: crun package: crun-1.20-1.1.x86_64 path: /usr/bin/crun version: |- crun version 1.20 commit: 9c9a76ac11994701dd666c4f0b869ceffb599a66 rundir: /run/user/1000/crun spec: 1.0.0 +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +LIBKRUN +WASM:wasmedge +YAJL os: linux pasta: executable: /usr/bin/pasta package: passt-20250217.a1e48a0-1.1.x86_64 version: &quot;&quot; remoteSocket: exists: true path: /run/user/1000/podman/podman.sock rootlessNetworkCmd: pasta security: apparmorEnabled: false capabilities: CAP_CHOWN,CAP_DAC_OVERRIDE,CAP_FOWNER,CAP_FSETID,CAP_KILL,CAP_NET_BIND_SERVICE,CAP_SETFCAP,CAP_SETGID,CAP_SETPCAP,CAP_SETUID,CAP_SYS_CHROOT rootless: true seccompEnabled: true seccompProfilePath: /usr/share/containers/seccomp.json selinuxEnabled: false serviceIsRemote: false slirp4netns: executable: /usr/bin/slirp4netns package: slirp4netns-1.3.2-1.1.x86_64 version: |- slirp4netns version 1.3.2 commit: unknown libslirp: 4.9.0 SLIRP_CONFIG_VERSION_MAX: 6 libseccomp: 2.6.0 swapFree: 0 swapTotal: 0 uptime: 7h 39m 47.00s (Approximately 0.29 days) variant: &quot;&quot; plugins: authorization: null log: - k8s-file - none - passthrough - journald network: - bridge - macvlan - ipvlan volume: - local registries: search: - registry.opensuse.org - registry.suse.com - docker.io store: configFile: /home/yuri/.config/containers/storage.conf containerStore: number: 7 paused: 0 running: 1 stopped: 6 graphDriverName: overlay graphOptions: overlay.mount_program: Executable: /usr/bin/fuse-overlayfs Package: fuse-overlayfs-1.13-1.4.x86_64 Version: |- fusermount3 version: 3.16.2 fuse-overlayfs: version 1.13-dev FUSE library version 3.16.2 using FUSE kernel interface version 7.38 graphRoot: /home/yuri/.local/share/containers/storage graphRootAllocated: 1997713440768 graphRootUsed: 312674549760 graphStatus: Backing Filesystem: btrfs Native Overlay Diff: &quot;false&quot; Supports d_type: &quot;true&quot; Supports shifting: &quot;true&quot; Supports volatile: &quot;true&quot; Using metacopy: &quot;false&quot; imageCopyTmpDir: /var/tmp imageStore: number: 24 runRoot: /run/user/1000/containers transientStore: false volumePath: /home/yuri/.local/share/containers/storage/volumes version: APIVersion: 5.4.0 Built: 1740036195 BuiltTime: Thu Feb 20 08:23:15 2025 GitCommit: &quot;&quot; GoVersion: go1.23.6 Os: linux OsArch: linux/amd64 Version: 5.4.0 ``` ### Podman in a container No ### Privileged Or Rootless None ### Upstream Latest Release Yes ### Additional environment details Additional environment details ### Additional information @Luap99</DESCRIPTION>
  <REPONAME>podman</REPONAME>
  <TIMEDIFFERENCEDAYS>1</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>Merge pull request #25450 from baude/issue25449 Replace old nginx image with podman hello</MESSAGE>
    <SHA>faf8574bb47870f275cd97f5088bc5de5baa2558</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>libpod: race in WaitForExit() with autoremove When waiting for container to be not-running, sometimes wait retuns code -1 with an empty error instead of actual exit code. It turned out that syncContainer returns ErrCtrRemoved for a removed container instead of ErrNoSuchCtr, while data can still be pulled from the database. This fixes #25479 by taking into account both codes.</MESSAGE>
      <SHA>0ea23542b8f69a5110d6ec1a2807ffae1d76ed3f</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container_api.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>libpod: race in WaitForExit() with autoremove When waiting for container to be not-running, sometimes wait retuns code -1 with an empty error instead of actual exit code. It turned out that syncContainer returns ErrCtrRemoved for a removed container instead of ErrNoSuchCtr, while data can still be pulled from the database. This fixes the issue by taking into account both codes. Fixes: #25479 Signed-off-by: Yuri Timenkov &lt;yuri@timenkov.pro&gt;</MESSAGE>
      <SHA>d0efd0e2781690b5bcfe2ac71a20e638c1199434</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container_api.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>libpod: race in WaitForConditionWithInterval() There are multiple concurrent goroutinces which produce result and they race agains each other, while producing different results. This commit addresses at least a part of the problem - producing different results for competing &quot;sources&quot;. Fixes: #25479 Signed-off-by: Yuri Timenkov &lt;yuri@timenkov.pro&gt;</MESSAGE>
      <SHA>eed5f9ee4afc9064cefdb47473a07766b8ba3af5</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container_api.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>libpod: race in WaitForExit() with autoremove When waiting for container to be not-running, sometimes wait retuns code -1 with an empty error instead of actual exit code. It turned out that syncContainer returns ErrCtrRemoved for a removed container instead of ErrNoSuchCtr, while data can still be pulled from the database. This fixes the issue by taking into account both codes. Fixes: #25479 Signed-off-by: Yuri Timenkov &lt;yuri@timenkov.pro&gt;</MESSAGE>
      <SHA>ab7c54b4cf38bd2246c9ef76440a23ccafdf0289</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container_api.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>libpod: race in WaitForConditionWithInterval() There are multiple concurrent goroutinces which produce result and they race agains each other, while producing different results. This commit addresses at least a part of the problem - producing different results for competing &quot;sources&quot;. Fixes: #25479 Signed-off-by: Yuri Timenkov &lt;yuri@timenkov.pro&gt;</MESSAGE>
      <SHA>cd8582d4f0049f7442c7a45bc3b156e5bc0a0192</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container_api.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>libpod: race in WaitForExit() with autoremove When waiting for container to be not-running, sometimes wait retuns code -1 with an empty error instead of actual exit code. It turned out that syncContainer returns ErrCtrRemoved for a removed container instead of ErrNoSuchCtr, while data can still be pulled from the database. This fixes the issue by taking into account both codes. Fixes: #25479 Signed-off-by: Yuri Timenkov &lt;yuri@timenkov.pro&gt;</MESSAGE>
      <SHA>c064bf5ffeb37bb12272689fc04e027838532667</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container_api.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>libpod: race in WaitForConditionWithInterval() There are multiple concurrent goroutinces which produce result and they race agains each other, while producing different results. This commit addresses at least a part of the problem - producing different results for competing &quot;sources&quot;. Fixes: #25479 Signed-off-by: Yuri Timenkov &lt;yuri@timenkov.pro&gt;</MESSAGE>
      <SHA>e9b6aa5cba6ccd63bc1a85520baf24e343c89dcc</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container_api.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>libpod: race in WaitForExit() with autoremove When waiting for container to be not-running, sometimes wait retuns code -1 with an empty error instead of actual exit code. It turned out that syncContainer returns ErrCtrRemoved for a removed container instead of ErrNoSuchCtr, while data can still be pulled from the database. This fixes the issue by taking into account both codes. Fixes: #25479 Signed-off-by: Yuri Timenkov &lt;yuri@timenkov.pro&gt;</MESSAGE>
      <SHA>7e564d1dc3a331bb1a0a16d822a32293b5dd739a</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container_api.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
    <COMMIT>
      <MESSAGE>libpod: race in WaitForConditionWithInterval() There are multiple concurrent goroutinces which produce result and they race agains each other, while producing different results. This commit addresses at least a part of the problem - producing different results for competing &quot;sources&quot;. Fixes: #25479 Signed-off-by: Yuri Timenkov &lt;yuri@timenkov.pro&gt;</MESSAGE>
      <SHA>85767f052442fb335cb51f9dc29f68d8bd865804</SHA>
      <PATCHEDFILES>
        <FILE>libpod/container_api.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
