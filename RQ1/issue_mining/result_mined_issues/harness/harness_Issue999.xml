<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>999</ISSUENO>
  <ISSUEURL>https://github.com/harness/harness/issues/999</ISSUEURL>
  <TITLE>question: why are PRs built against their original predecessor</TITLE>
  <DESCRIPTION>Ditto. I see two conflicting angles here: 1. a PR has the most chance of getting built against its predecessor (ie the original parent revision) 2. the _Merge pull request_ action would pull the commits and then merge them, so the consecutive build may produce a vastly different result (when other PRs are merged before) The thing here is that (2) may fail even if (1) succeeded. It would be really nice to run CI on the &quot;post merge&quot; code, whatever it happens to be at the time. That, however, is a moving target as PRs get merged in parallel... What is the most meaningful way forward?</DESCRIPTION>
  <REPONAME>harness</REPONAME>
  <TIMEDIFFERENCEDAYS>355</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>Add rule to block PR merge if changes are requested by reviewer (#1054)</MESSAGE>
    <SHA>6f270eb3ae12ffdae945e750adf710c43d8200fa</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>List all Repos at Account level or Space Level recursively (#999)</MESSAGE>
      <SHA>c94930859653fad4b24f985e651d46ca9e4cfc53</SHA>
      <PATCHEDFILES>
        <FILE>app/api/controller/space/delete.go</FILE>
        <FILE>app/api/controller/space/list_repositories.go</FILE>
        <FILE>app/api/handler/space/list_repos.go</FILE>
        <FILE>app/api/openapi/space.go</FILE>
        <FILE>app/api/request/repo.go</FILE>
        <FILE>app/store/database.go</FILE>
        <FILE>app/store/database/repo.go</FILE>
        <FILE>app/store/database/repo_test.go</FILE>
        <FILE>app/store/database/setup_test.go</FILE>
        <FILE>app/store/database/space_test.go</FILE>
        <FILE>types/enum/order.go</FILE>
        <FILE>types/repo.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
