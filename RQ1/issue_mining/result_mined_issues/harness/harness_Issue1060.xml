<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>1060</ISSUENO>
  <ISSUEURL>https://github.com/harness/harness/issues/1060</ISSUEURL>
  <TITLE>Use DSN strings for configuration</TITLE>
  <DESCRIPTION>&gt; **TL;DR** configuration needs more flexibility to support plugins without being overly abstracted. The existing 0.4 implementation is overly abstracted, inflexible, and is increasingly difficult to map to environment variables. With the 0.4 release we are introducing a plugin model that allows certain pieces of Drone to be completely replaced, for example, the database layer, the queue layer, etc. This requires an added level of flexibility in terms of configuration that is difficult to achieve with the current `drone.toml` **Issue: Static Typing** This is due primarily to the nature of Go and static typing. We decode the toml into a structure that has a pre-defined hierarchy and set of fields. It is highly likely that a plugin will need configuration parameters that are not defined in the toml. **Issue: Toml vs Env** A more complex `drone.toml` file is increasingly difficult to represent the configuration in Toml and Environment variables. Environment variable are the recommended method to define configuration (per 12-factor apps) and has become the emerging standard in the Docker community. Ideally we could implement a single approach and move on. We have bigger and more important things to focus on. **Looking Forward: Systemd** Systemd is now the standard init system on almost all Linux distributions, which gives us options for configuration that did not exist with upstart. Specifically, the ability to define `EnvironmentFile=` --- **Proposal** The proposal is to use environment variables as the sole method to configuration Drone along with DSN formatting configuration strings. The systemd init file will look like this: ``` ini EnvironmentFile=/etc/drone/drone.conf ``` And the configuration file will look like this: ``` sh SERVER_ADDR=&quot;:80&quot; SERVER_CRT=&quot;/path/to/cert.crt&quot; SERVER_KEY=&quot;/path/to/key.key&quot; DATABASE=&quot;postgres://user:pass@localhost/foo&quot; REMOTE=&quot;github://token:secret@github.com?open=false&amp;orgs=foo,bar&quot; ``` **DSN format** So how do we give different plugins (ie queue, database, etc) flexible configuration capabilities? After doing a bit of research I believe database abstractions (ie `jdbc`, `database/sql`, etc) have already solved this issue with connection strings in DSN format. The DSN format typically looks like the following: `&lt;driver&gt;://&lt;user&gt;:&lt;pass&gt;@&lt;host&gt;?&lt;key&gt;=&lt;value&gt;`. The most important part of the configuration URL (for Drone) is the `&lt;driver&gt;://` section, so that Drone knows which Driver to load. The remainder of the string is simply passed along to the Driver. This means the Driver itself determines the string format, and has a good amount of flexibility. **Remote Examples** ``` github://&lt;client&gt;:&lt;secret&gt;@github.com?open=false&amp;orgs=foo,bar gitlab://&lt;client&gt;:&lt;secret&gt;@foo.com?open=false&amp;orgs=foo,bar&amp;ssl=skip bitbucket://&lt;client&gt;:&lt;secret&gt;@bitbucket.org ``` Or maybe someone wants to create a custom remote plugin, that runs as an RCP service: ``` tcp://&lt;username&gt;:&lt;password&gt;@localhost ``` **Database Examples** ``` sqlite:///var/lib/drone/drone.sqlite postgres://root:@localhost/drone ``` **Queue Examples** ``` redis://localhost:5367 ``` The benefit is that the URI format is defined by the plugin. This means that Drone will enable any configuration that can fit inside a URI, which has worked pretty well for databases over the years. **Challenges** This is probably out of scope for `0.4.0`, however, it would be interesting to make the Docker backend pluggable as well. For example, could we allow people to choose `swarm` or `mesos` as a backend? ``` docker:///var/run/docker.sock?ca=/path/to/ca&amp;cert=/path/to/cert&amp;key=/path/to/key swarm://6856663cdefdec325839a4b7e1de38e8@swarm-master.cloudapp.net:4243 ``` The only real challenge here that I need to think through is how to supply multiple Docker deamon endpoints. The above example only provides a single daemon URL, however, it is likely that larger installations will need to declare multiple. Suggestions welcome.</DESCRIPTION>
  <REPONAME>harness</REPONAME>
  <TIMEDIFFERENCEDAYS>65</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>feat: [CODE-1258]: made window title more meaningful for CODE module (#1058)</MESSAGE>
    <SHA>aae15eb5a5c60a2d7e46d17e9c7fd69d572638ee</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>[GIT] fix output for getting single commit without parents (#1060)</MESSAGE>
      <SHA>1d74fcde4c26889f8dadc91e7eb0cb7ed54ce59d</SHA>
      <PATCHEDFILES>
        <FILE>git/adapter/commit.go</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
