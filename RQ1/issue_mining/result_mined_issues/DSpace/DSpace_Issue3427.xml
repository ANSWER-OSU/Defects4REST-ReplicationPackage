<?xml version="1.0" ?>
<ISSUE>
  <ISSUENO>3427</ISSUENO>
  <ISSUEURL>https://github.com/DSpace/DSpace/issues/3427</ISSUEURL>
  <TITLE>[DS-49] Add support for DjVu-documents - ID: 2234659</TITLE>
  <DESCRIPTION>&lt;i&gt;Imported from JIRA &lt;a href=&quot;https://jira.lyrasis.org/browse/DS-49&quot;&gt;[DS-49]&lt;/a&gt; created by kipkorir2008&lt;/i&gt; &lt;p&gt;Hello All&lt;/p&gt; &lt;p&gt;This patch based on&lt;br/&gt; &lt;a href=&quot;http://mailman.mit.edu/pipermail/dspace-general/2007-May/001513.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://mailman.mit.edu/pipermail/dspace-general/2007-May/001513.html&lt;/a&gt;&lt;/p&gt; &lt;p&gt;In DSpace 1.5.0+ we need (before compilation)&lt;/p&gt; &lt;p&gt;1) Add utility djvutxt (package djvulibre), for Debian it is:&lt;br/&gt; apt-get install djvulibre-bin&lt;/p&gt; &lt;p&gt;2) Edit &lt;span class=&quot;error&quot;&gt;&amp;#91;dspace-source&amp;#93;&lt;/span&gt;/dspace/config/dspace.cfg, text-block &quot;### Media&lt;br/&gt; Filter / Format Filter plugins&quot;&lt;br/&gt; and add DjVu-support in 3 places:&lt;/p&gt; &lt;p&gt;filter.plugins = ... \&lt;br/&gt; DjVu Text Extractor&lt;/p&gt; &lt;p&gt;plugin.named.org.dspace.app.mediafilter.FormatFilter = ... \&lt;br/&gt; org.dspace.app.mediafilter.DjVuFilter = DjVu Text Extractor&lt;/p&gt; &lt;p&gt;filter.org.dspace.app.mediafilter.DjVuFilter.inputFormats = DjVu&lt;/p&gt; &lt;p&gt;3) Edit &lt;span class=&quot;error&quot;&gt;&amp;#91;dspace-source&amp;#93;&lt;/span&gt;/dspace/config/registries/bitstream-formats.xml&lt;br/&gt; and add next&lt;/p&gt; &lt;p&gt;&lt;bitstream-type&gt;&lt;br/&gt; &lt;mimetype&gt;image/vnd.djvu&lt;/mimetype&gt;&lt;br/&gt; &lt;short_description&gt;DjVu&lt;/short_description&gt;&lt;br/&gt; &lt;description&gt;DjVu&lt;/description&gt;&lt;br/&gt; &lt;support_level&gt;1&lt;/support_level&gt;&lt;br/&gt; &lt;internal&gt;false&lt;/internal&gt;&lt;br/&gt; &lt;extension&gt;djvu&lt;/extension&gt;&lt;br/&gt; &lt;extension&gt;djv&lt;/extension&gt;&lt;br/&gt; &lt;/bitstream-type&gt;&lt;/p&gt; &lt;p&gt;4) Create file&lt;br/&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;dspace-source&amp;#93;&lt;/span&gt;/dspace-api/src/main/java/org/dspace/app/mediafilter/DjVuFil&lt;br/&gt; ter.java&lt;br/&gt; with next content&lt;/p&gt; &lt;p&gt;/*&lt;br/&gt; DjVuFilter.java&lt;br/&gt; Version: 0.1&lt;br/&gt; DSpace version: 1.4.2 beta&lt;br/&gt; Author: Ivan Penev&lt;br/&gt; e-mail: inpenev at gmail.com&lt;br/&gt; */&lt;/p&gt; &lt;p&gt;package org.dspace.app.mediafilter;&lt;/p&gt; &lt;p&gt;import java.io.InputStream;&lt;br/&gt; import java.io.FileInputStream;&lt;br/&gt; import java.io.BufferedInputStream;&lt;br/&gt; import java.io.ByteArrayInputStream;&lt;br/&gt; import java.io.OutputStream;&lt;br/&gt; import java.io.FileOutputStream;&lt;br/&gt; import java.io.BufferedOutputStream;&lt;br/&gt; import java.io.FileReader;&lt;br/&gt; import java.io.BufferedReader;&lt;br/&gt; import java.io.File;&lt;/p&gt; &lt;p&gt;/**&lt;/p&gt; &lt;ul&gt; &lt;li&gt;This class provides a media filter for processing files of type DjVu.&lt;/li&gt; &lt;li&gt;&lt;p&gt;The current implementation uses a program called&lt;br/&gt; &lt;code&gt;djvutxt&lt;/code&gt;, which extracts the text layer from a previously&lt;br/&gt; OCR-ed DjVu file and saves it into a UTF-8 text document. The program&lt;br/&gt; is distributed with the &lt;code&gt;djvulibre&lt;/code&gt; package which is freely&lt;br/&gt; available under the GPL license from &lt;a&lt;br/&gt; href=&quot;http://djvu.sourceforge.net/&quot;&gt;&lt;a href=&quot;http://djvu.sourceforge.net/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://djvu.sourceforge.net/&lt;/a&gt;&lt;/a&gt;&lt;br/&gt; for both Unix and Windows operating systems. Hence, for the media&lt;br/&gt; filter to work it is required that &lt;code&gt;djvutxt&lt;/code&gt; is a valid&lt;br/&gt; command (in the working environment).&lt;/p&gt;&lt;br/&gt; */&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;public class DjVuFilter extends MediaFilter&lt;br/&gt; {&lt;br/&gt; /**&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Get a filename for a newly created filtered bitstream.&lt;br/&gt; *&lt;/li&gt; &lt;li&gt;@param sourceName&lt;/li&gt; &lt;li&gt;name of source bitstream&lt;/li&gt; &lt;li&gt;@return filename generated by the filter - for example, document.djvu&lt;/li&gt; &lt;li&gt;becomes document.djvu.txt&lt;br/&gt; */&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;public String getFilteredName(String sourceName)&lt;br/&gt; {&lt;br/&gt; return sourceName + &quot;.txt&quot;;&lt;br/&gt; }&lt;/p&gt; &lt;p&gt;/**&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Get name of the bundle this filter will stick its generated&lt;br/&gt; bitstreams.&lt;br/&gt; *&lt;/li&gt; &lt;li&gt;@return &quot;TEXT&quot;&lt;br/&gt; */&lt;br/&gt; public String getBundleName()&lt;br/&gt; {&lt;br/&gt; return &quot;TEXT&quot;;&lt;br/&gt; }&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;/**&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Get name of the bitstream format returned by this filter.&lt;br/&gt; *&lt;/li&gt; &lt;li&gt;@return &quot;Text&quot;&lt;br/&gt; */&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;public String getFormatString()&lt;br/&gt; {&lt;br/&gt; return &quot;Text&quot;;&lt;br/&gt; }&lt;/p&gt; &lt;p&gt;/**&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Get a string describing the newly-generated bitstream.&lt;br/&gt; *&lt;/li&gt; &lt;li&gt;@return &quot;Extracted text&quot;&lt;br/&gt; */&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;public String getDescription()&lt;br/&gt; {&lt;br/&gt; return &quot;Extracted text&quot;;&lt;br/&gt; }&lt;/p&gt; &lt;p&gt;/**&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Get a bitstream filled with the extracted text from a DjVu bitstream.&lt;/li&gt; &lt;li&gt;&lt;p&gt;The bitstream supplied as a parameter is written to a DjVu&lt;br/&gt; file on the file system (in the working directory), and the system&lt;br/&gt; command &lt;code&gt;djvutxt&lt;/code&gt; is called on the latter to produce a&lt;br/&gt; UTF-8 text file containg the extracted text. The file is then copied&lt;br/&gt; to a bitstream. Finally, the auxiliary files are removed from the file&lt;br/&gt; system, and the generated bitsream is returned as a result.&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;WARNING! Write access to the working directory is needed for&lt;br/&gt; this method to operate! No exception handling provided!&lt;/p&gt;&lt;br/&gt; *&lt;/li&gt; &lt;li&gt;@param source&lt;/li&gt; &lt;li&gt;input stream&lt;br/&gt; *&lt;/li&gt; &lt;li&gt;@return result of filter's transformation, written out to a bitstream&lt;br/&gt; */&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;public InputStream getDestinationStream(InputStream source) throws&lt;br/&gt; Exception&lt;br/&gt; {&lt;br/&gt; /* Some convenience initializations. */&lt;br/&gt; final String cmd = &quot;djvutxt&quot;;&lt;br/&gt; final String fileName = &quot;aux&quot;;&lt;br/&gt; final String djvuFileName = fileName + &quot;.djvu&quot;;&lt;br/&gt; final String txtFileName = fileName + &quot;.txt&quot;;&lt;/p&gt; &lt;p&gt;/* Store input bitstresam to auxiliary DjVu file. */&lt;br/&gt; File djvuFile = streamToFile(source, djvuFileName);&lt;/p&gt; &lt;p&gt;/* Invoke external command djvutxt with appropriate agruments&lt;br/&gt; to do the actual job... */&lt;br/&gt; final String[] cmdArray = &lt;/p&gt; {cmd, djvuFileName, txtFileName} &lt;p&gt;;&lt;br/&gt; Process p = Runtime.getRuntime().exec(cmdArray);&lt;br/&gt; /* ...and wait for it to terminate */&lt;br/&gt; p.waitFor();&lt;/p&gt; &lt;p&gt;/* Copy extracted text from file to an independent bitstream,&lt;br/&gt; and optionally print the text to standard output. */&lt;br/&gt; File txtFile = new File(txtFileName);&lt;br/&gt; InputStream dest = fileToStream(txtFile, MediaFilterManager.isVerbose);&lt;/p&gt; &lt;p&gt;/* Then remove auxiliary files...*/&lt;br/&gt; djvuFile.delete();&lt;br/&gt; txtFile.delete();&lt;br/&gt; /* ...and return resulting bitstream. */&lt;br/&gt; return dest;&lt;br/&gt; }&lt;/p&gt; &lt;p&gt;/**&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Write given input stream to a file on the file system.&lt;/li&gt; &lt;li&gt;&lt;p&gt;WARNING! No exception handling!&lt;/p&gt;&lt;br/&gt; *&lt;/li&gt; &lt;li&gt;@param inStream input stream&lt;/li&gt; &lt;li&gt;@param fileName name of the file to be generated&lt;br/&gt; *&lt;/li&gt; &lt;li&gt;@return &lt;code&gt;File&lt;/code&gt; object associated with the generated file&lt;br/&gt; *&lt;/li&gt; &lt;li&gt;@throws Exception&lt;br/&gt; */&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;private File streamToFile(InputStream inStream, String fileName)&lt;br/&gt; throws Exception&lt;/p&gt; { /* Data will be read from input stream in chunks of size e.g. 4KB. */ final int chunkSize = 4096; byte[] byteArray = new byte[chunkSize]; /* Open the stream for buffered reading. */ InputStream bufInStream = new BufferedInputStream(inStream); /* Create an empty file (if the file already exists, it will be left untouched) to store the supplied bitstream... */ File file = new File(fileName); file.createNewFile(); /* ...and associate a buffered output stream with it. */ OutputStream bufOutStream = new BufferedOutputStream(new FileOutputStream(file)); /* Copy data from input stream to newly generated file. */ int readBytes = -1; while ((readBytes = bufInStream.read(byteArray, 0, chunkSize)) != -1) bufOutStream.write(byteArray, 0, readBytes); /* Stop transactions to the file system... */ bufOutStream.close(); /* ...and return result. */ return file; } /** * Produce input stream from a given file on the file system. * &lt;p&gt;WARNING! No exception handling!&lt;/p&gt; * * @param file &lt;code&gt;File&lt;/code&gt; object associated with the given file * * @return input stream containing the data read from file * *@throws Exception */ private InputStream fileToStream(File file, boolean verbose) throws Exception { /* Open the stream for reading. */ InputStream inStream = new FileInputStream(file); /* Allocate necessary memory for data buffer. */ byte[] byteArray = new byte[(int)file.length()]; /* Load file contents into buffer. */ inStream.read(byteArray); /* And imediately close transactions with the file system. */ inStream.close(); /* If required to send the retrieved data to standard output... */ if (verbose) { /* Open the file again, but this tim handle it as a character stream... */ BufferedReader bufReader = new BufferedReader(new FileReader(file)); /* ...then print its contents line by line to the standard output... */ String lineOfText = null; while ((lineOfText = bufReader.readLine()) != null) System.out.println(lineOfText); /* ...and close connection to the file. */ bufReader.close(); } /* Finally, generate and return input stream containing desired data. */ return new ByteArrayInputStream(byteArray); } } &lt;p&gt;5) Compilation/recompilation&lt;br/&gt; cd &lt;span class=&quot;error&quot;&gt;&amp;#91;dspace-source&amp;#93;&lt;/span&gt;/dspace/dspace-1.5.0-src-release/dspace/&lt;br/&gt; mvn package&lt;/p&gt; &lt;p&gt;6) Install or for recompilation - &lt;/p&gt; {edit work bitstream-formats.xml &amp; dspace.cfg as above and replace dspace-api-1.5.0.jar from folders webapps/jspui/WEB-INF/lib/, lib/, webapps/lni/WEB-INF/lib/, webapps/oai/WEB-INF/lib/, webapps/xmlui/WEB-INF/lib/ by compiled [dspace-source]/dspace-api/target/dspace-api-1.5.0.jar} &lt;p&gt;7) Don't forgive restart Tomcat and run&lt;br/&gt; /usr/share/dspace/bin/filter-media&lt;/p&gt; &lt;p&gt;With best regards&lt;br/&gt; Serhij Dubyk&lt;/p&gt;</DESCRIPTION>
  <REPONAME>DSpace</REPONAME>
  <TIMEDIFFERENCEDAYS>198</TIMEDIFFERENCEDAYS>
  <BUGGYCOMMIT>
    <MESSAGE>Merged in task/glam7/GLAM-911 (pull request #3413) [GLAM-911] Approved-by: Giuseppe Digilio</MESSAGE>
    <SHA>16d76f6ebf13ca4fdb7a7bac0a1fb19ca40d4392</SHA>
  </BUGGYCOMMIT>
  <PATCHCOMMITS>
    <COMMIT>
      <MESSAGE>Merged in task/glam7/GLAM-982 (pull request #3427) [GLAM-982] Approved-by: Giuseppe Digilio</MESSAGE>
      <SHA>2b52d432978f230c70c5841abfea94dc8d870ccc</SHA>
      <PATCHEDFILES>
        <FILE>dspace/config/item-submission.xml</FILE>
        <FILE>dspace/config/submission-forms.xml</FILE>
      </PATCHEDFILES>
    </COMMIT>
  </PATCHCOMMITS>
</ISSUE>
