issue_no,repo,issue_url,title,description,patched_file_types
282,elassandra,https://github.com/strapdata/elassandra/issues/282,Unable to create geo_shape index,"Elassandra version: 6.2.3.13-14 jvm: openjdk version ""1.8.0_212"" OS: Linux 631697ed6903 4.9.0-8-amd64 #1 SMP Debian 4.9.144-3.1 (2019-02-19) x86_64 GNU/Linux docker image: strapdata/elassandra:latest Hello, i'm trying to create geo_shape index for field with following request: PUT http://localhost:9200/weather `{ ""settings"": { ""keyspace"":""weather"" }, ""mappings"": { ""weather_data"" : { ""_source"": { ""enabled"": true }, ""properties"": { ""geom"": { ""type"":""geo_shape"" } } } } }` got the error: `{ ""error"": { ""root_cause"": [ { ""type"": ""mapper_parsing_exception"", ""reason"": ""Failed to execute query:null : Existing column [geom] type [text] mismatch with inferred type [list<text>]"" } ], ""type"": ""mapper_parsing_exception"", ""reason"": ""Failed to execute query:null : Existing column [geom] type [text] mismatch with inferred type [list<text>]"", ""caused_by"": { ""type"": ""configuration_exception"", ""reason"": ""Existing column [geom] type [text] mismatch with inferred type [list<text>]"" } }, ""status"": 400 }` The weather table: `CREATE TABLE weather.weather_data ( id text, updated_at timestamp, alt int, created_at timestamp, es_options text, es_query text, geom text, predict tinyint, radius int, time timestamp, type tinyint, version bigint, weather text, x int, y int, PRIMARY KEY (id, updated_at) ) WITH CLUSTERING ORDER BY (updated_at DESC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'NONE'} AND comment = '' AND compaction = {'class': 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy', 'max_threshold': '32', 'min_threshold': '4'} AND compression = {'chunk_length_in_kb': '64', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1.0 AND dclocal_read_repair_chance = 0.1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND read_repair_chance = 0.0 AND speculative_retry = '99PERCENTILE';` Why geo_shape index needs list<text> type? And if add 'cql_collection' parameter to index request: `{ ""settings"": { ""keyspace"":""weather"" }, ""mappings"": { ""weather_data"" : { ""_source"": { ""enabled"": true }, ""properties"": { ""geom"": { ""type"":""geo_shape"", ""cql_collection"":""singleton"" } } } } }` I got the following error: `{ ""error"": { ""root_cause"": [ { ""type"": ""mapper_parsing_exception"", ""reason"": ""Mapping definition for [geom] has unsupported parameters: [cql_collection : singleton]"" } ], ""type"": ""mapper_parsing_exception"", ""reason"": ""Failed to parse mapping [weather_data]: Mapping definition for [geom] has unsupported parameters: [cql_collection : singleton]"", ""caused_by"": { ""type"": ""mapper_parsing_exception"", ""reason"": ""Mapping definition for [geom] has unsupported parameters: [cql_collection : singleton]"" } }, ""status"": 400 }` How can I create geo_shape index with field type 'text'?",test-file | source-file
70,elassandra,https://github.com/strapdata/elassandra/issues/70,ES DELETE by index/type fails for time-series indices,"There seems to be a possible bug or difference in the way plan indices are handled (ie: test_index) vs. timeseries indices (ie: test-2017.01.01) particularly evident on DELETE actions:  Successful DELETE: test_index <pre> DELETE test_index PUT _template/test_template { ""template"": ""test_index"", ""mappings"": { ""_default_"": { ""properties"": { ""attachment"": { ""type"": ""binary"" }, ""report"": { ""type"": ""boolean"" }, ""payload"": { ""type"": ""object"", ""enabled"": false } } } } } PUT test_index/test_type/test12 { ""@timestamp"": ""2016-12-27T19:14:00.012Z"", ""level"": ""INFO"", ""message"": ""test message"", ""action"": ""test_action"", ""payload"": {}, ""report"": false } DELETE test_index/test_type/test12 </pre>  Failed DELETE on index: test_index-2016.12.29 <pre> DELETE test_index* PUT _template/test_template { ""template"": ""test_index-*"", ""mappings"": { ""_default_"": { ""properties"": { ""attachment"": { ""type"": ""binary"" }, ""report"": { ""type"": ""boolean"" }, ""payload"": { ""type"": ""object"", ""enabled"": false } } } } } PUT test_index-2016.12.29/test_type/test12 { ""@timestamp"": ""2016-12-27T19:14:00.012Z"", ""level"": ""INFO"", ""message"": ""test message"", ""action"": ""test_action"", ""payload"": {}, ""report"": false } GET test_index-2016.12.29/_search DELETE test_index-2016.12.29/test_type/test12 </pre> Which results in the following error: <pre> { ""error"": { ""root_cause"": [ { ""type"": ""action_request_validation_exception"", ""reason"": ""Validation Failed: 1: test_index-2016.12.29.test_type table does not exists;"" } ], ""type"": ""action_request_validation_exception"", ""reason"": ""Validation Failed: 1: test_index-2016.12.29.test_type table does not exists;"" }, ""status"": 400 } </pre> Any suggestion as of what might be causing this?",data-file | test-file
163,elassandra,https://github.com/strapdata/elassandra/issues/163,Invalid date mapping,"<!-- GitHub is reserved for bug reports and feature requests. The best place to ask a general question is at the Elastic Discourse forums at https://discuss.elastic.co. If you are in fact posting a bug report or a feature request, please include one and only one of the below blocks in your new issue. Note that whether you're filing a bug report or a feature request, ensure that your submission is for an [OS that we support](https://www.elastic.co/support/matrix#show_os). Bug reports on an OS that we do not support or feature requests specific to an OS that we do not support will be closed. --> <!-- If you are filing a bug report, please remove the below feature request block and provide responses for all of the below items. --> **Elasticsearch version**: 5.5.0 **Plugins installed**: [] **JVM version**: 8 **OS version**: **Description of the problem including expected versus actual behavior**: **Steps to reproduce**: 1. create table with date field  create table date_elassandra_test ( id int primary key, somedate date );  2. create mapping on it  PUT http://node:9200/myspace/date_elassandra_test/_mapping { ""date_elassandra_test"": { ""properties"": { ""somedate"": { ""type"": ""date"", ""cql_collection"": ""singleton"" } } } }  3. insert some data `insert into date_elassandra_test (id,somedate) values (1,'2018-02-03');` 4. check search result  POST http://node:9200/myspace/date_elassandra_test/_search  {  ""_source"": { ""somedate"": ""-5877593-07-26T00:00:00.000Z"" }  } As you see - somedate is somehow offseted date for ElasticSearch. But if TIMESTAMP cassandra type is used instead - all is well",test-file | source-file | documentation-file
65,elassandra,https://github.com/strapdata/elassandra/issues/65,java.io.IOException: from is a reserved keyword,"Bonjour Vincent, Using latest build, I am attempting to create custom index mapping including object types resulting in a faceted issue - filing them together as they seem two faces of the same coin so to speak.  java.io.IOException: from is a reserved keyword  PUT watcher { ""mappings"": { ""watch"": { ""properties"": { ""id"": { ""type"": ""string"", ""index"": ""not_analyzed"" }, ""condition"": { ""type"":""object"", ""enabled"": false }, ""input"": { ""type"":""object"", ""enabled"": false }, ""transform"": { ""type"":""object"", ""enabled"": false } } } } }  followed by a document creation attempt:  PUT watcher/watch/test_watch_random { ""disabled"": false, ""id"": ""test_watch_random"", ""trigger"": { ""schedule"": { ""later"": ""every 5 minutes"" } }, ""input"": { ""search"": { ""request"": { ""index"": [], ""body"": {} } } }, ""condition"": { ""script"": { ""script"": ""payload.hits.total > 100"" } }, ""transform"": {}, ""actions"": { ""email_admin"": { ""throttle_period"": ""15m"", ""email"": { ""to"": ""alarm@localhost"", ""from"": ""sentinl@localhost"", ""subject"": ""Sentinl Alarm"", ""priority"": ""high"", ""body"": ""Found {{payload.hits.total}} Events"" } } } }  The first response of Elassandra is:  { ""error"": { ""root_cause"": [ { ""type"": ""runtime_exception"", ""reason"": ""java.io.IOException: from is a reserved keyword"" } ], ""type"": ""runtime_exception"", ""reason"": ""java.io.IOException: from is a reserved keyword"", ""caused_by"": { ""type"": ""i_o_exception"", ""reason"": ""from is a reserved keyword"", ""caused_by"": { ""type"": ""configuration_exception"", ""reason"": ""from is a reserved keyword"" } } }, ""status"": 500 }  with logs:  2016-12-26 08:51:11,257 WARN [elasticsearch[127.0.0.1][http_server_worker][T#3]{New I/O worker #53}] BytesRestResponse.java:134 convert path: /watcher2/watch/test_watch_random, params: {index=watcher2, id=test_watch_random, type=watch} java.lang.RuntimeException: java.io.IOException: from is a reserved keyword at org.elassandra.cluster.InternalCassandraClusterService$BlockingActionListener.waitForUpdate(InternalCassandraClusterService.java:1820) at org.elassandra.cluster.InternalCassandraClusterService.blockingMappingUpdate(InternalCassandraClusterService.java:1842) at org.elassandra.cluster.InternalCassandraClusterService.upsertDocument(InternalCassandraClusterService.java:1879) at org.elassandra.cluster.InternalCassandraClusterService.insertDocument(InternalCassandraClusterService.java:1852) at org.elasticsearch.action.index.TransportXIndexAction.innerExecute(TransportXIndexAction.java:85) at org.elasticsearch.action.index.TransportIndexAction.doExecute(TransportIndexAction.java:120) at org.elasticsearch.action.index.TransportIndexAction.doExecute(TransportIndexAction.java:66) at org.elasticsearch.action.support.TransportAction.execute(TransportAction.java:137) at org.elasticsearch.action.support.TransportAction.execute(TransportAction.java:85) at org.elasticsearch.client.node.NodeClient.doExecute(NodeClient.java:58) at org.elasticsearch.client.support.AbstractClient.execute(AbstractClient.java:359) at org.elasticsearch.client.FilterClient.doExecute(FilterClient.java:52) at org.elasticsearch.rest.BaseRestHandler$HeadersAndContextCopyClient.doExecute(BaseRestHandler.java:88) at org.elasticsearch.client.support.AbstractClient.execute(AbstractClient.java:359) at org.elasticsearch.client.support.AbstractClient.index(AbstractClient.java:371) at org.elasticsearch.rest.action.index.RestIndexAction.handleRequest(RestIndexAction.java:105) at org.elasticsearch.rest.BaseRestHandler.handleRequest(BaseRestHandler.java:54) at org.elasticsearch.rest.RestController.executeHandler(RestController.java:198) at org.elasticsearch.rest.RestController.dispatchRequest(RestController.java:158) at org.elasticsearch.http.HttpServer.internalDispatchRequest(HttpServer.java:153) at org.elasticsearch.http.HttpServer$Dispatcher.dispatchRequest(HttpServer.java:101) at org.elasticsearch.http.netty.NettyHttpServerTransport.dispatchRequest(NettyHttpServerTransport.java:451) at org.elasticsearch.http.netty.HttpRequestHandler.messageReceived(HttpRequestHandler.java:61) at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:70) at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564) at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791) at org.elasticsearch.http.netty.pipelining.HttpPipeliningHandler.messageReceived(HttpPipeliningHandler.java:60) at org.jboss.netty.channel.SimpleChannelHandler.handleUpstream(SimpleChannelHandler.java:88) at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564) at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791) at org.jboss.netty.handler.codec.http.HttpChunkAggregator.messageReceived(HttpChunkAggregator.java:145) at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:70) at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564) at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791) at org.jboss.netty.handler.codec.http.HttpContentDecoder.messageReceived(HttpContentDecoder.java:108) at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:70) at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564) at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791) at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:296) at org.jboss.netty.handler.codec.frame.FrameDecoder.unfoldAndFireMessageReceived(FrameDecoder.java:459) at org.jboss.netty.handler.codec.replay.ReplayingDecoder.callDecode(ReplayingDecoder.java:536) at org.jboss.netty.handler.codec.replay.ReplayingDecoder.messageReceived(ReplayingDecoder.java:435) at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:70) at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564) at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791) at org.elasticsearch.common.netty.OpenChannelsHandler.handleUpstream(OpenChannelsHandler.java:75) at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564) at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559) at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:268) at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:255) at org.jboss.netty.channel.socket.nio.NioWorker.read(NioWorker.java:88) at org.jboss.netty.channel.socket.nio.AbstractNioWorker.process(AbstractNioWorker.java:108) at org.jboss.netty.channel.socket.nio.AbstractNioSelector.run(AbstractNioSelector.java:337) at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:89) at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:178) at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:108) at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) Caused by: java.io.IOException: from is a reserved keyword at org.elassandra.cluster.InternalCassandraClusterService.updateTableSchema(InternalCassandraClusterService.java:1185) at org.elasticsearch.cluster.metadata.MetaDataMappingService$PutMappingExecutor.applyRequest(MetaDataMappingService.java:391) at org.elasticsearch.cluster.metadata.MetaDataMappingService$PutMappingExecutor.execute(MetaDataMappingService.java:280) at org.elasticsearch.cluster.service.InternalClusterService.runTasksForExecutor(InternalClusterService.java:540) at org.elasticsearch.cluster.service.InternalClusterService$UpdateTask.run(InternalClusterService.java:902) at org.elasticsearch.common.util.concurrent.PrioritizedEsThreadPoolExecutor$TieBreakingPrioritizedRunnable.runAndClean(PrioritizedEsThreadPoolExecutor.java:231) at org.elasticsearch.common.util.concurrent.PrioritizedEsThreadPoolExecutor$TieBreakingPrioritizedRunnable.run(PrioritizedEsThreadPoolExecutor.java:194)  3 common frames omitted Caused by: org.apache.cassandra.exceptions.ConfigurationException: from is a reserved keyword at org.elassandra.cluster.InternalCassandraClusterService.buildUDT(InternalCassandraClusterService.java:795) at org.elassandra.cluster.InternalCassandraClusterService.buildCql(InternalCassandraClusterService.java:744) at org.elassandra.cluster.InternalCassandraClusterService.buildUDT(InternalCassandraClusterService.java:772) at org.elassandra.cluster.InternalCassandraClusterService.buildCql(InternalCassandraClusterService.java:744) at org.elassandra.cluster.InternalCassandraClusterService.buildUDT(InternalCassandraClusterService.java:772) at org.elassandra.cluster.InternalCassandraClusterService.buildCql(InternalCassandraClusterService.java:744) at org.elassandra.cluster.InternalCassandraClusterService.updateTableSchema(InternalCassandraClusterService.java:1093)  9 common frames omitted  Interestingly, attempting the very same insert unchanged, works:  { ""_index"": ""watcher"", ""_type"": ""watch"", ""_id"": ""test_watch_random"", ""_version"": 1, ""_shards"": { ""total"": 1, ""successful"": 1, ""failed"": 0 }, ""created"": true }  and gets indexed correctly:  GET watcher/_search { ""took"": 5, ""timed_out"": false, ""_shards"": { ""total"": 1, ""successful"": 1, ""failed"": 0 }, ""hits"": { ""total"": 1, ""max_score"": 1, ""hits"": [ { ""_index"": ""watcher"", ""_type"": ""watch"", ""_id"": ""test_watch_random"", ""_score"": 1, ""_source"": { ""input"": ""{\""search\"":{\""request\"":{\""index\"":[],\""body\"":{"", ""condition"": ""{\""script\"":{\""script\"":\""payload.hits.total > 100\""}}"", ""transform"": ""{}"", ""id"": ""test_name"" } } ] } }   Pure Object documents not searchable Attempting to create a mapping without an ""enabled"" field seems to fail harder - the above mapping/document without the ""string"" id field is accepted but returns no search results afterwards. Here's an adapted example to reproduce:  PUT watcher_fail { ""mappings"": { ""watch"": { ""properties"": { ""condition"": { ""type"":""object"", ""enabled"": false }, ""input"": { ""type"":""object"", ""enabled"": false }, ""transform"": { ""type"":""object"", ""enabled"": false } } } } }  followed by a document creation attempt:  PUT watcher_fail/watch/this_doc_will_be_missing { ""trigger"": { ""schedule"": { ""later"": ""every 5 minutes"" } }, ""input"": { ""search"": { ""request"": { ""index"": [], ""body"": {} } } }, ""condition"": { ""script"": { ""script"": ""payload.hits.total > 100"" } }, ""transform"": {}, ""actions"": { ""email_admin"": { ""throttle_period"": ""15m"", ""email"": { ""to"": ""alarm@localhost"", ""from"": ""sentinl@localhost"", ""subject"": ""Sentinl Alarm"", ""priority"": ""high"", ""body"": ""Found {{payload.hits.total}} Events"" } } } }  The above document should get accepted, but will never be available in search:  GET watcher_fail/_search",source-file
323,elassandra,https://github.com/strapdata/elassandra/issues/323,Elassandra mappings with type coercing aren't behaving the same as elasticsearch,"<!-- Bug report --> **Elassandra version**: 6.8.4.0 **JVM version** (`java -version`): docker image **OS version** (`uname -a` if on a Unix-like system): host system is OSx but I also tested it in GKE. **Description of the problem including expected versus actual behavior**: When using a mapping template, that enables type coercing, Elassandra doesn't behave the same as ElasticSearch. Instead it returns a 500 and an exception. **Steps to reproduce**: In both of these examples we'll be inserting a document that has an integer mapping. And in both cases the int field's value will be submitted as a string value.  Testing Elasticsearch 6.8  docker pull docker.elastic.co/elasticsearch/elasticsearch:6.8.6 docker run -p 9200:9200 -p 9300:9300 -e ""discovery.type=single-node"" docker.elastic.co/elasticsearch/elasticsearch:6.8.6 export HOST=localhost export INDEX=ents_type_site1 echo '{ ""index_patterns"": ""ents_*"", ""mappings"": { ""_doc"": { ""properties"": { ""_created"": { ""type"": ""date"" } }, ""dynamic_templates"": [ { ""integer_fields"": { ""match"": ""int_*"", ""mapping"": { ""coerce"": true, ""type"": ""long"" } } } ] } } }' | http PUT http://$HOST:9200/_template/ent_table_template { ""acknowledged"": true } echo '{""int__eventcnt"":""1""}' | http POST http://$HOST:9200/$INDEX/_doc/a1bc=:1cd== { ""_id"": ""a1bc=:1cd=="", ""_index"": ""ents_type_site1"", ""_primary_term"": 1, ""_seq_no"": 0, ""_shards"": { ""failed"": 0, ""successful"": 1, ""total"": 2 }, ""_type"": ""_doc"", ""_version"": 1, ""result"": ""created"" }  * Note that elasticsearch handled the casting of the string to an int.  Testing elassandra 6.8  docker run -p 9200:9200 -p 9300:9300 --name node0 -d strapdata/elassandra:6.8.4.0 export INDEX=ents_type_site1 echo '{ ""index_patterns"": ""ents_*"", ""mappings"": { ""_doc"": { ""properties"": { ""_created"": { ""type"": ""date"" } }, ""dynamic_templates"": [ { ""integer_fields"": { ""match"": ""int_*"", ""mapping"": { ""coerce"": true, ""type"": ""long"" } } } ] } } }' | http PUT http://$HOST:9200/_template/ent_table_template { ""acknowledged"": true } echo '{""int__eventcnt"":""1""}' | http POST http://$HOST:9200/$INDEX/_doc/a1bc=:1cd== { ""error"": { ""reason"": ""java.lang.String cannot be cast to java.lang.Number"", ""root_cause"": [ { ""reason"": ""[172.17.0.2][172.17.0.2:9300][indices:data/write/bulk[s][p]]"", ""type"": ""remote_transport_exception"" } ], ""type"": ""class_cast_exception"" }, ""status"": 500 }  **Please provide the following information**: * elassandra logs (logs/system.logs or /var/lib/cassandra/system.log)  2020-01-10 06:01:40,015 WARN [elasticsearch[172.17.0.2][http_server_worker][T#2]] org.elasticsearch.common.logging.DeprecationLogger.deprecated(DeprecationLogger.java:242) [types removal] The parameter include_type_name should be explicitly specified in put template requests to prepare for 7.0. In 7.0 include_type_name will default to 'false', and requests are expected to omit the type name in mapping definitions. 2020-01-10 06:01:42,691 INFO [elasticsearch[172.17.0.2][generic][T#3]] org.elassandra.shard.CassandraShardStateListener.afterIndexShardStarted(CassandraShardStateListener.java:69) shard [ents_type_site1][0] started 2020-01-10 06:01:42,994 ERROR [elasticsearch[172.17.0.2][write][T#1]] org.elassandra.cluster.QueryManager.upsertDocument(QueryManager.java:842) [java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number].[ents_type_site1] failed to parse field _doc=int__eventcnt 2020-01-10 06:01:43,011 WARN [elasticsearch[172.17.0.2][write][T#1]] org.elasticsearch.rest.BytesRestResponse.build(BytesRestResponse.java:133) path: /ents_type_site1/_doc/a1bc=:1cd==, params: {index=ents_type_site1, id=a1bc=:1cd==, type=_doc} org.elasticsearch.transport.RemoteTransportException: [172.17.0.2][172.17.0.2:9300][indices:data/write/bulk[s][p]] Caused by: java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number at org.elasticsearch.index.mapper.NumberFieldMapper$NumberType$7.cqlValue(NumberFieldMapper.java:870) at org.elasticsearch.index.mapper.NumberFieldMapper$NumberFieldType.cqlValue(NumberFieldMapper.java:1057) at org.elasticsearch.index.mapper.MappedFieldType.cqlValue(MappedFieldType.java:423) at org.elassandra.cluster.Serializer.serialize(Serializer.java:230) at org.elassandra.cluster.Serializer.serialize(Serializer.java:223) at org.elassandra.cluster.QueryManager.upsertDocument(QueryManager.java:840) at org.elassandra.cluster.QueryManager.insertDocument(QueryManager.java:694) at org.elasticsearch.action.bulk.TransportShardBulkAction.lambda$executeIndexRequestOnPrimary$3(TransportShardBulkAction.java:468) at org.elasticsearch.action.bulk.TransportShardBulkAction.executeOnPrimaryWhileHandlingMappingUpdates(TransportShardBulkAction.java:495) at org.elasticsearch.action.bulk.TransportShardBulkAction.executeIndexRequestOnPrimary(TransportShardBulkAction.java:464) at org.elasticsearch.action.bulk.TransportShardBulkAction.executeBulkItemRequest(TransportShardBulkAction.java:226) at org.elasticsearch.action.bulk.TransportShardBulkAction.performOnPrimary(TransportShardBulkAction.java:169) at org.elasticsearch.action.bulk.TransportShardBulkAction.performOnPrimary(TransportShardBulkAction.java:160) at org.elasticsearch.action.bulk.TransportShardBulkAction.shardOperationOnPrimary(TransportShardBulkAction.java:146) at org.elasticsearch.action.bulk.TransportShardBulkAction.shardOperationOnPrimary(TransportShardBulkAction.java:83) at org.elasticsearch.action.support.replication.TransportReplicationAction$PrimaryShardReference.perform(TransportReplicationAction.java:1088) at org.elasticsearch.action.support.replication.TransportReplicationAction$PrimaryShardReference.perform(TransportReplicationAction.java:1066) at org.elasticsearch.action.support.replication.ReplicationOperation.execute(ReplicationOperation.java:105) at org.elasticsearch.action.support.replication.TransportReplicationAction$AsyncPrimaryAction.runWithPrimaryShardReference(TransportReplicationAction.java:445) at org.elasticsearch.action.support.replication.TransportReplicationAction$AsyncPrimaryAction.doRun(TransportReplicationAction.java:387) at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37) at org.elasticsearch.action.support.replication.TransportReplicationAction$PrimaryOperationTransportHandler.messageReceived(TransportReplicationAction.java:327) at org.elasticsearch.action.support.replication.TransportReplicationAction$PrimaryOperationTransportHandler.messageReceived(TransportReplicationAction.java:314) at org.elasticsearch.transport.RequestHandlerRegistry.processMessageReceived(RequestHandlerRegistry.java:66) at org.elasticsearch.transport.TransportService$7.doRun(TransportService.java:696) at org.elasticsearch.common.util.concurrent.ThreadContext$ContextPreservingAbstractRunnable.doRun(ThreadContext.java:751) at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)  * elasticsearch cluster state (curl http://localhost:9200/_cluster/state) * cassandra schema (cqlsh>DESC KEYSPACE <your_keyspace>) * cassandra gossip state (run: nodetool gossipinfo)",test-file | source-file
7,elassandra,https://github.com/strapdata/elassandra/issues/7,Build string on ES startpage is empty,"error show build numer:  { ""name"" : ""abc"", ""cluster_name"" : ""Test Cluster"", ""version"" : { ""number"" : ""2.1.2"", ""build_hash"" : ""${buildNumber}"", ""build_timestamp"" : ""NA"", ""build_snapshot"" : true, ""lucene_version"" : ""5.3.1"" }, ""tagline"" : ""You Know, for Search"" }",data-file | config-file
346,elassandra,https://github.com/strapdata/elassandra/issues/346,"Nested objects with inner hits query returns ""extracted source isn't an object or an array""","<!-- Bug report --> **Elassandra version**: Behavior is seen on official docker images [6.8.4.0](https://hub.docker.com/layers/strapdata/elassandra/6.8.4.0/images/sha256-1e004ecccfc506faf806464e4beed1815d3c973ee6d3bb4b88193084397d8491?context=explore) -> [6.8.4.5](https://hub.docker.com/layers/strapdata/elassandra/6.8.4.5/images/sha256-1a7ff3e3c1ee0801f812aa321dfe4ae8a6f959c3ef47b0fbeaa3a4de695eff14?context=explore) **Plugins installed**: None **JVM version** (`java -version`): Docker image of 6.8.4.5 is running openjdk version ""1.8.0_252"" **OS version** (`uname -a` if on a Unix-like system): Running on a container on a host that is running 18.04.1-Ubuntu **Description of the problem including expected versus actual behavior**: I am moving from 6.2.3.28 to 6.8.4.5, and have noticed queries with inner hits on nested objects (as outlined in the steps below) are failing with the following error coming back:  { ""error"": { ""root_cause"": [ { ""type"": ""illegal_state_exception"", ""reason"": ""extracted source isn't an object or an array"" } ], ""type"": ""search_phase_execution_exception"", ""reason"": ""all shards failed"", ""phase"": ""query"", ""grouped"": true, ""failed_shards"": [ { ""shard"": 0, ""index"": ""nested_data"", ""node"": ""5c622bfa-fef0-4dd0-b040-5a68a767beb5"", ""reason"": { ""type"": ""illegal_state_exception"", ""reason"": ""extracted source isn't an object or an array"" } } ], ""caused_by"": { ""type"": ""illegal_state_exception"", ""reason"": ""extracted source isn't an object or an array"", ""caused_by"": { ""type"": ""illegal_state_exception"", ""reason"": ""extracted source isn't an object or an array"" } } }, ""status"": 500 }  **Reasons why I think this is a bug:** 1. When tested against [ES 6.8.4 docker image](https://hub.docker.com/layers/elasticsearch/library/elasticsearch/6.8.4/images/sha256-87538ba78df48470563796df1dbbf2e7bf407e97542830bfd395f912b15c07f0?context=explore) I do not see the same issue. 2. I do not see this issue on Elassandra 6.2.3.28, and assume there is backwards compatibility of query/mapping/docs on non major version releases **Other behaviors I noted:** Removing the inner_hits block of the query stops the issue, and so does turning off the source in the inner_hits block. However neither of these are desirable solutions Something else that seems to resolve the issue while I was triaging is removing `nested-object2` when inserting the data in step 2 below **Steps to reproduce**: 1. Create index at `nested_data` with the following mapping:  { ""mappings"": { ""nested_data"": { ""properties"": { ""parent-nested"": { ""type"": ""nested"", ""properties"": { ""nested-object1"": { ""type"": ""nested"", ""properties"": { ""field1"": { ""type"": ""text"" }, ""field2"": { ""type"": ""text"", ""fields"": { ""keyword"": { ""type"": ""keyword"", ""ignore_above"": 256 } } } } }, ""nested-object2"": { ""type"": ""nested"", ""properties"": { ""field2"": { ""type"": ""text"" } } } } } } } } }  2. Insert the following document in the above created index:  { ""parent-nested"": [ { ""nested-object1"": [ { ""field1"": ""hello"" } ] }, { ""nested-object2"": { } } ] }  3. Run the following query against the index:  { ""query"": { ""bool"": { ""must"": [ { ""nested"": { ""path"": ""parent-nested.nested-object1"", ""inner_hits"": { }, ""query"": { ""bool"": { ""should"": { ""bool"": { ""must"": { ""match"": { ""parent-nested.nested-object1.field1"": ""hello"" } } } } } } } } ] } } }  **Please provide the following information**: * elassandra logs:  elassandra | Elassandra started elassandra | 2020-06-04 17:51:31,748 WARN [elasticsearch[172.18.0.2][http_server_worker][T#2]] org.elasticsearch.common.logging.DeprecationLogger.deprecated(DeprecationLogger.java:242) [types removal] The parameter include_type_name should be explicitly specified in create index requests to prepare for 7.0. In 7.0 include_type_name will default to 'false', and requests are expected to omit the type name in mapping definitions. elassandra | 2020-06-04 17:51:33,174 INFO [elasticsearch[172.18.0.2][generic][T#2]] org.elassandra.shard.CassandraShardStateListener.afterIndexShardStarted(CassandraShardStateListener.java:69) shard [nested_data][0] started elassandra | 2020-06-04 17:51:46,971 WARN [elasticsearch[172.18.0.2][search][T#1]] org.elasticsearch.rest.BytesRestResponse.build(BytesRestResponse.java:133) path: /nested_data/_search, params: {index=nested_data} elassandra | org.elasticsearch.action.search.SearchPhaseExecutionException: all shards failed elassandra | at org.elasticsearch.action.search.AbstractSearchAsyncAction.onPhaseFailure(AbstractSearchAsyncAction.java:298) elassandra | at org.elasticsearch.action.search.AbstractSearchAsyncAction.executeNextPhase(AbstractSearchAsyncAction.java:135) elassandra | at org.elasticsearch.action.search.AbstractSearchAsyncAction.onPhaseDone(AbstractSearchAsyncAction.java:261) elassandra | at org.elasticsearch.action.search.InitialSearchPhase.onShardFailure(InitialSearchPhase.java:100) elassandra | at org.elasticsearch.action.search.InitialSearchPhase.access$100(InitialSearchPhase.java:48) elassandra | at org.elasticsearch.action.search.InitialSearchPhase$2.lambda$onFailure$1(InitialSearchPhase.java:220) elassandra | at org.elasticsearch.action.search.InitialSearchPhase.maybeFork(InitialSearchPhase.java:174) elassandra | at org.elasticsearch.action.search.InitialSearchPhase.access$000(InitialSearchPhase.java:48) elassandra | at org.elasticsearch.action.search.InitialSearchPhase$2.onFailure(InitialSearchPhase.java:220) elassandra | at org.elasticsearch.action.search.SearchExecutionStatsCollector.onFailure(SearchExecutionStatsCollector.java:73) elassandra | at org.elasticsearch.action.ActionListenerResponseHandler.handleException(ActionListenerResponseHandler.java:59) elassandra | at org.elasticsearch.action.search.SearchTransportService$ConnectionCountingHandler.handleException(SearchTransportService.java:463) elassandra | at org.elasticsearch.transport.TransportService$ContextRestoreResponseHandler.handleException(TransportService.java:1118) elassandra | at org.elasticsearch.transport.TransportService$DirectResponseChannel.processException(TransportService.java:1230) elassandra | at org.elasticsearch.transport.TransportService$DirectResponseChannel.sendResponse(TransportService.java:1204) elassandra | at org.elasticsearch.transport.TaskTransportChannel.sendResponse(TaskTransportChannel.java:60) elassandra | at org.elasticsearch.action.support.ChannelActionListener.onFailure(ChannelActionListener.java:56) elassandra | at org.elasticsearch.search.SearchService$2.onFailure(SearchService.java:368) elassandra | at org.elasticsearch.search.SearchService$2.onResponse(SearchService.java:362) elassandra | at org.elasticsearch.search.SearchService$2.onResponse(SearchService.java:356) elassandra | at org.elasticsearch.search.SearchService$4.doRun(SearchService.java:1114) elassandra | at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37) elassandra | at org.elasticsearch.common.util.concurrent.TimedRunnable.doRun(TimedRunnable.java:41) elassandra | at org.elasticsearch.common.util.concurrent.ThreadContext$ContextPreservingAbstractRunnable.doRun(ThreadContext.java:751) elassandra | at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37) elassandra | at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) elassandra | at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) elassandra | at java.lang.Thread.run(Thread.java:748) elassandra | Caused by: org.elasticsearch.ElasticsearchException$1: extracted source isn't an object or an array elassandra | at org.elasticsearch.ElasticsearchException.guessRootCauses(ElasticsearchException.java:657) elassandra | at org.elasticsearch.action.search.AbstractSearchAsyncAction.executeNextPhase(AbstractSearchAsyncAction.java:133) elassandra |  26 common frames omitted elassandra | Caused by: java.lang.IllegalStateException: extracted source isn't an object or an array elassandra | at org.elasticsearch.search.fetch.FetchPhase.createNestedSearchHit(FetchPhase.java:340) elassandra | at org.elasticsearch.search.fetch.FetchPhase.execute(FetchPhase.java:166) elassandra | at org.elasticsearch.search.fetch.subphase.InnerHitsFetchSubPhase.hitsExecute(InnerHitsFetchSubPhase.java:69) elassandra | at org.elasticsearch.search.fetch.FetchPhase.execute(FetchPhase.java:184) elassandra | at org.elasticsearch.search.SearchService.executeFetchPhase(SearchService.java:424) elassandra | at org.elasticsearch.search.SearchService.executeQueryPhase(SearchService.java:404) elassandra | at org.elasticsearch.search.SearchService.access$100(SearchService.java:127) elassandra | at org.elasticsearch.search.SearchService$2.onResponse(SearchService.java:360) elassandra |  9 common frames omitted elassandra | 2020-06-04 18:06:06,393 WARN [elasticsearch[172.18.0.2][search][T#2]] org.elasticsearch.rest.BytesRestResponse.build(BytesRestResponse.java:133) path: /nested_data/_search, params: {index=nested_data} elassandra | org.elasticsearch.action.search.SearchPhaseExecutionException: all shards failed elassandra | at org.elasticsearch.action.search.AbstractSearchAsyncAction.onPhaseFailure(AbstractSearchAsyncAction.java:298) elassandra | at org.elasticsearch.action.search.AbstractSearchAsyncAction.executeNextPhase(AbstractSearchAsyncAction.java:135) elassandra | at org.elasticsearch.action.search.AbstractSearchAsyncAction.onPhaseDone(AbstractSearchAsyncAction.java:261) elassandra | at org.elasticsearch.action.search.InitialSearchPhase.onShardFailure(InitialSearchPhase.java:100) elassandra | at org.elasticsearch.action.search.InitialSearchPhase.access$100(InitialSearchPhase.java:48) elassandra | at org.elasticsearch.action.search.InitialSearchPhase$2.lambda$onFailure$1(InitialSearchPhase.java:220) elassandra | at org.elasticsearch.action.search.InitialSearchPhase.maybeFork(InitialSearchPhase.java:174) elassandra | at org.elasticsearch.action.search.InitialSearchPhase.access$000(InitialSearchPhase.java:48) elassandra | at org.elasticsearch.action.search.InitialSearchPhase$2.onFailure(InitialSearchPhase.java:220) elassandra | at org.elasticsearch.action.search.SearchExecutionStatsCollector.onFailure(SearchExecutionStatsCollector.java:73) elassandra | at org.elasticsearch.action.ActionListenerResponseHandler.handleException(ActionListenerResponseHandler.java:59) elassandra | at org.elasticsearch.action.search.SearchTransportService$ConnectionCountingHandler.handleException(SearchTransportService.java:463) elassandra | at org.elasticsearch.transport.TransportService$ContextRestoreResponseHandler.handleException(TransportService.java:1118) elassandra | at org.elasticsearch.transport.TransportService$DirectResponseChannel.processException(TransportService.java:1230) elassandra | at org.elasticsearch.transport.TransportService$DirectResponseChannel.sendResponse(TransportService.java:1204) elassandra | at org.elasticsearch.transport.TaskTransportChannel.sendResponse(TaskTransportChannel.java:60) elassandra | at org.elasticsearch.action.support.ChannelActionListener.onFailure(ChannelActionListener.java:56) elassandra | at org.elasticsearch.search.SearchService$2.onFailure(SearchService.java:368) elassandra | at org.elasticsearch.search.SearchService$2.onResponse(SearchService.java:362) elassandra | at org.elasticsearch.search.SearchService$2.onResponse(SearchService.java:356) elassandra | at org.elasticsearch.search.SearchService$4.doRun(SearchService.java:1114) elassandra | at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37) elassandra | at org.elasticsearch.common.util.concurrent.TimedRunnable.doRun(TimedRunnable.java:41) elassandra | at org.elasticsearch.common.util.concurrent.ThreadContext$ContextPreservingAbstractRunnable.doRun(ThreadContext.java:751) elassandra | at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37) elassandra | at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) elassandra | at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) elassandra | at java.lang.Thread.run(Thread.java:748) elassandra | Caused by: org.elasticsearch.ElasticsearchException$1: extracted source isn't an object or an array elassandra | at org.elasticsearch.ElasticsearchException.guessRootCauses(ElasticsearchException.java:657) elassandra | at org.elasticsearch.action.search.AbstractSearchAsyncAction.executeNextPhase(AbstractSearchAsyncAction.java:133) elassandra |  26 common frames omitted elassandra | Caused by: java.lang.IllegalStateException: extracted source isn't an object or an array elassandra | at org.elasticsearch.search.fetch.FetchPhase.createNestedSearchHit(FetchPhase.java:340) elassandra | at org.elasticsearch.search.fetch.FetchPhase.execute(FetchPhase.java:166) elassandra | at org.elasticsearch.search.fetch.subphase.InnerHitsFetchSubPhase.hitsExecute(InnerHitsFetchSubPhase.java:69) elassandra | at org.elasticsearch.search.fetch.FetchPhase.execute(FetchPhase.java:184) elassandra | at org.elasticsearch.search.SearchService.executeFetchPhase(SearchService.java:424) elassandra | at org.elasticsearch.search.SearchService.executeQueryPhase(SearchService.java:404) elassandra | at org.elasticsearch.search.SearchService.access$100(SearchService.java:127) elassandra | at org.elasticsearch.search.SearchService$2.onResponse(SearchService.java:360) elassandra |  9 common frames omitted  * cassandra schema:  CREATE KEYSPACE nested_data WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1': '1'} AND durable_writes = true; CREATE TYPE nested_data.nested_data_parent_nested_nested_object1 ( field1 list<text>, field2 list<text> ); CREATE TYPE nested_data.nested_data_parent_nested_nested_object2 ( field2 list<text> ); CREATE TYPE nested_data.nested_data_parent_nested ( ""nested-object1"" list<frozen<nested_data_parent_nested_nested_object1>>, ""nested-object2"" list<frozen<nested_data_parent_nested_nested_object2>> ); CREATE TABLE nested_data.nested_data ( ""_id"" text PRIMARY KEY, ""parent-nested"" list<frozen<nested_data_parent_nested>> ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'NONE'} AND comment = '' AND compaction = {'class': 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy', 'max_threshold': '32', 'min_threshold': '4'} AND compression = {'chunk_length_in_kb': '64', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1.0 AND dclocal_read_repair_chance = 0.1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND read_repair_chance = 0.0 AND speculative_retry = '99PERCENTILE'; CREATE CUSTOM INDEX elastic_nested_data_idx ON nested_data.nested_data () USING 'org.elassandra.index.ExtendedElasticSecondaryIndex';",test-file | source-file
68,elassandra,https://github.com/strapdata/elassandra/issues/68,ES Object Type stringified in search,"When inserting fields mapped as object type contents are returned as strings in search. In comparison my stock ES 2.x returns object fields as a valid JSON objects without escaping.  Steps to Reproduce * Create Mapping: json PUT watcher/watch/_mapping { ""properties"": { ""uuid"": { ""type"": ""string"", ""index"": ""not_analyzed"" }, ""condition"": { ""type"":""object"", ""enabled"": false } } }  * Insert document with object fields json PUT watcher/watch/test_watch_random23 { ""uuid"": ""test"", ""trigger"": { ""schedule"": { ""later"": ""every 1 minutes"" } }, ""condition"": { ""script"": { ""script"": ""payload.hits.total > 1"" } } }  * Query results, objects are returned as strings  GET watcher/_search { ""took"": 6, ""timed_out"": false, ""_shards"": { ""total"": 1, ""successful"": 1, ""failed"": 0 }, ""hits"": { ""total"": 1, ""max_score"": 1, ""hits"": [ { ""_index"": ""watcher"", ""_type"": ""watch"", ""_id"": ""test_watch_random23"", ""_score"": 1, ""_source"": { ""condition"": ""{\""script\"":{\""script\"":\""payload.hits.total > 1\""}}"", ""trigger"": { ""schedule"": { ""later"": ""every 1 minutes"" } }, ""uuid"": ""test"" } } ] } }",test-file | source-file
295,elassandra,https://github.com/strapdata/elassandra/issues/295,dots in object mapping ignored,"**Describe the feature**: Dots in object-field names are silently ignored **Elassandra version**: 6.2.3.15 **Plugins installed**: [] **JVM version** (`java -version`): OpenJDK Runtime Environment (build 1.8.0_212-8u212-b01-1~deb9u1-b01) OpenJDK 64-Bit Server VM (build 25.212-b01, mixed mode) **OS version** (`uname -a` if on a Unix-like system): Linux db1-dev 4.9.0-9-amd64 #1 SMP Debian 4.9.168-1+deb9u2 (2019-05-13) x86_64 GNU/Linux **Description of the problem including expected versus actual behavior**: **Steps to reproduce**: **1. Create empty index - e.g. testindex** **2. PUT /testindex/_doc/1** Request-Body: { ""us.er"" : ""test"", ""postdate"" : ""2009-11-15T14:12:12"", ""message"" : ""Test123"" } i get the following response document: { ""_index"": ""testindex"", ""_type"": ""_doc"", ""_id"": ""1"", ""_version"": 1, ""result"": ""created"", ""_shards"": { ""total"": 1, ""successful"": 1, ""failed"": 0 } } **3. GET on http://127.0.0.1:9200/testindex/_doc/1** { ""_index"": ""testindex"", ""_type"": ""_doc"", ""_id"": ""1"", ""_version"": 1, ""found"": true, ""_source"": { ""postdate"": ""2009-11-15T14:12:12.000Z"", ""message"": ""Test123"" } } the field with the dot in the name (us.er) is silently ignored.",test-file | source-file
298,elassandra,https://github.com/strapdata/elassandra/issues/298,build_hash and build_date as Unknown after Installing ELS,"Hi, Post installation of elassandra i see output of curl -X GET http://localhost:9200/ having build_hash and build_date as Unknown Could you please fix the same? Thanks Ashish",source-file
